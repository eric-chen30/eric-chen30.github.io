<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title>Hexo</title>
    <link href="http://example.com" />
    <updated>2020-09-12T07:59:46.000Z</updated>
    <category term="Docker" />
    <entry>
        <id>http://example.com/2020/09/12/Docker%E5%85%A5%E9%97%A8/</id>
        <title>Docker入门</title>
        <link rel="alternate" href="http://example.com/2020/09/12/Docker%E5%85%A5%E9%97%A8/"/>
        <content type="html">&lt;h1 id=&#34;docker入门&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#docker入门&#34;&gt;#&lt;/a&gt; Docker 入门&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;docker&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;仓库，镜像，容器&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;why：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;开发代码 ----&amp;gt; 运维工程师不一定能运行&lt;/p&gt;
&lt;p&gt;环境 / 配置不同 -&amp;gt; 导致相同代码不一定能成功运行得到正确结果&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简化：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将代码 / 依赖 / 配置 / 环境等一系列进行打包形成一个统一的镜像&lt;/p&gt;
&lt;p&gt;这个统一的镜像可以在较为简单的环境下成功运行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;比喻：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个集装箱代表一个运行环境，相互分离，互不干扰&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虚拟机：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在一种操作系统里运行另一种操作系统，跟真实系统一模一样&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;区别：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虚拟机运行分钟级，而 docker 则是秒级&lt;/p&gt;
&lt;p&gt;虚拟里占用资源多，包含了硬件，软件一整套操作系统&lt;/p&gt;
&lt;p&gt;docker 轻量级的，且基于宿主机的内核&lt;/p&gt;
&lt;p&gt;Linux 容器不是模拟一个完整的操作系统，按需导入&lt;/p&gt;
&lt;p&gt;docker 可以认为是一种精简版的 linux 环境，更简洁，灵活&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;资源：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2RvY2tlci1jbi5jb20=&#34;&gt;docker-cn.com&lt;/span&gt;    //docker 中文网&lt;/p&gt;
&lt;p&gt;Docker Hub        //docker 仓库&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Docker 安装：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;centos 6.5 或更高的版本&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;uname -r        cat  /etc/redhat-release    // 查看 centos 版本&lt;/p&gt;
&lt;p&gt;epel-release    //epel 安装 docker 依赖库   tag：6.8&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2RvY2tlci5pbw==&#34;&gt;docker.io&lt;/span&gt;         // 正式的 docker 镜像      tag：6.8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;7.0 版本不同，具体参考官方文档&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三部分：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;client--------&amp;gt;docker bulid / pull / run&lt;/p&gt;
&lt;p&gt;docker_host---------&amp;gt;Docker  daemon&lt;/p&gt;
&lt;p&gt;repository-------------&amp;gt; 仓库&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;理解：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;镜像 ------ 是只读模板&lt;/p&gt;
&lt;p&gt;容器 ------ 时利用镜像创造的实例，可以看作简易版的 linux&lt;/p&gt;
&lt;p&gt;仓库 ------ 集中存放镜像文件   分为公开库 / 私有库&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;阿里云 / 网易云镜像加速：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注册账号&lt;/p&gt;
&lt;p&gt;获得阿里云加速器链接&lt;/p&gt;
&lt;p&gt;配置文件&lt;/p&gt;
&lt;p&gt;重载配置文件 / 重启 docker&lt;/p&gt;
&lt;p&gt;检查是否生效  ps -ef | grep docker&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;docker run 查找顺序:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本地容器 ------&amp;gt; 本地镜像 --------&amp;gt;hub 共有仓库去 pull 镜像 -----&amp;gt; 本地更具镜像实例一个容器&lt;/p&gt;
&lt;p&gt;比较：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;Docker%E5%85%A5%E9%97%A8.assets/image-20200410092551474.png&#34; alt=&#34;image-20200410092551474&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;docker 命令：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;systemctl  start  docker     // 启动 docker&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;docker images                  // 本地镜像模板&lt;/p&gt;
&lt;p&gt;-a  所有镜像     -q 所有镜像 id     --digests  摘要&lt;/p&gt;
&lt;p&gt;–no-trunc 完整镜像信息     // 参数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;docker search &amp;lt;images_name&amp;gt;   // 在 docker hub 共有仓库中搜寻镜像&lt;/p&gt;
&lt;p&gt;-s    星数限定      --no-trunc 完整镜像信息    --automated  只显示该类型镜像&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;docker  pull  &amp;lt;images_name&amp;gt;：tag   // 拉去某个特定版本镜像&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;docker rmi  &amp;lt;images_name&amp;gt;  // 运行时删除不了&lt;/p&gt;
&lt;p&gt;-f   强制删除&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;docker rmi -f  images1:tag  images2:tag  // 删除多个镜像&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;docker rmi -f  $(docker images -qa)    // 删除全部镜像&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img data-src=&#34;Docker%E5%85%A5%E9%97%A8.assets/image-20200410101552150.png&#34; alt=&#34;image-20200410101552150&#34;&gt;&lt;/p&gt;
&lt;img data-src=&#34;C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200410102315483.png&#34; alt=&#34;image-20200410102315483&#34; style=&#34;zoom:150%;&#34; /&gt;
&lt;p&gt;&lt;strong&gt;docker ps 的参数：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;Docker%E5%85%A5%E9%97%A8.assets/image-20200410102609893.png&#34; alt=&#34;image-20200410102609893&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;Docker%E5%85%A5%E9%97%A8.assets/image-20200410103523485.png&#34; alt=&#34;image-20200410103523485&#34;&gt;&lt;/p&gt;
&lt;p&gt;docker  run  -d centos   // 在后台运行，docker ps 无运行实例&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;Docker%E5%85%A5%E9%97%A8.assets/image-20200410104149792.png&#34; alt=&#34;image-20200410104149792&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;Docker%E5%85%A5%E9%97%A8.assets/image-20200410104329747.png&#34; alt=&#34;image-20200410104329747&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;docker ps -a 可查看后台运行的容器 id，并根据需求删除&lt;/p&gt;
&lt;p&gt;docker inspect 容器 id     // 查看容器内部的细节&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不停止退出容器后，重新进入容器的 bash&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;Docker%E5%85%A5%E9%97%A8.assets/image-20200410105415294.png&#34; alt=&#34;image-20200410105415294&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;Docker%E5%85%A5%E9%97%A8.assets/image-20200410105952961.png&#34; alt=&#34;image-20200410105952961&#34;&gt;&lt;/p&gt;
&lt;p&gt;docker cp 命令进行数据备份  将容器中的数据转移到宿主机上&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;Docker%E5%85%A5%E9%97%A8.assets/image-20200410110134891.png&#34; alt=&#34;image-20200410110134891&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;镜像原理：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;轻量的，可执行的独立软件包，用来打包软件和软件所需的运行环境&lt;/p&gt;
&lt;p&gt;docker 镜像实际上是一层层文件系统，这种为 UnionFile 层级文件系统&lt;/p&gt;
&lt;p&gt;一个文件的内存大，说明需要的层级文件多，依赖的环境复杂&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分层结构：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;优点 ------ 共享资源&lt;/p&gt;
&lt;p&gt;镜像层可读，容器层可写&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;docker commit     // 提交容器副本成为一个新的镜像&lt;/p&gt;
&lt;p&gt;-m “提交信息”    -a 作者    容器 ID  目标镜像名：tag&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;防火墙：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;systemctl status firewalld.service   // 查看防火墙状态&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;systemctl stop firewalld.service   // 关闭运行的防火墙&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;systemctl disable firewalld.service  // 永久关闭防火墙&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;docker 容器数据卷：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;保证数据的持久化，容器之间共享数据，数据同步&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;直接命令：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;docker run -it -v /myDataVolume:/dataVolumeContainer centos&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img data-src=&#34;Docker%E5%85%A5%E9%97%A8.assets/image-20200410154136675.png&#34; alt=&#34;image-20200410154136675&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;Docker%E5%85%A5%E9%97%A8.assets/image-20200410154151323.png&#34; alt=&#34;image-20200410154151323&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;Docker%E5%85%A5%E9%97%A8.assets/image-20200410155255440.png&#34; alt=&#34;image-20200410155255440&#34;&gt;&lt;/p&gt;
&lt;p&gt;:ro   // 修改权限为只读模式&lt;/p&gt;
&lt;p&gt;映射文件夹下无法新建文件，且无法修改文件，形成单方向同步&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DockerFile：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对镜像源码的描述，编译文件&lt;/p&gt;
&lt;p&gt;提示错误：“docker build” requires exactly 1 argument.&lt;/p&gt;
&lt;p&gt;原因是因为（少了一个 ‘.’ ， ‘.’ 代表当前路径）&lt;/p&gt;
&lt;p&gt;[root@docker mydocker]# docker build -f /mydocker/DockerFile -t cs/centos .&lt;/p&gt;
&lt;p&gt;. 打包当前目录&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据卷容器：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;容器间传递共享&lt;/p&gt;
&lt;p&gt;docker run -it --name dc01 cs/centos  // 父容器&lt;/p&gt;
&lt;p&gt;docker run -it --name dc02 --volumes-from dc01 cs/centos   // 子容器&lt;/p&gt;
&lt;p&gt;删除父容器 1，对 2，3 子容器不影响，干掉父容器 1，对 2，3 之间的数据共享也不影响&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DockerFile:  镜像构建文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;手动编写符合 file 规范的 dockerfile 文件&lt;/p&gt;
&lt;p&gt;docker build 命令执行，生成镜像&lt;/p&gt;
&lt;p&gt;docker run 执行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;dockerfile：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1，每条保留字指令都必须大写首字母，且保留字后不为空&lt;/p&gt;
&lt;p&gt;2，指令自上而下，顺序执行，# 表注释&lt;/p&gt;
&lt;p&gt;3，每条指令创建一个新的镜像层，并不断提交给镜像&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;Docker%E5%85%A5%E9%97%A8.assets/image-20200411091323256.png&#34; alt=&#34;image-20200411091323256&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;docker 执行 dockerfile 的大致流程：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1，docker 从基础镜像运行一个容器&lt;/p&gt;
&lt;p&gt;2，执行一条条指令，对容器进行修改&lt;/p&gt;
&lt;p&gt;3，执行 docker commit 提交新的镜像层，对镜像进行修改&lt;/p&gt;
&lt;p&gt;4，docker 基于新镜像在运行一个容器&lt;/p&gt;
&lt;p&gt;5，在依次类推，直到运行完所有指令&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;dockerfile 保留字：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;Docker%E5%85%A5%E9%97%A8.assets/image-20200411091833609.png&#34; alt=&#34;image-20200411091833609&#34;&gt;&lt;/p&gt;
&lt;p&gt;基础镜像&lt;/p&gt;
&lt;p&gt;作者说明&lt;/p&gt;
&lt;p&gt;执行命令&lt;/p&gt;
&lt;p&gt;指定对外暴露的端口&lt;/p&gt;
&lt;p&gt;进入终端的指定工作目录&lt;/p&gt;
&lt;p&gt;构建镜像中设置环境变量&lt;/p&gt;
&lt;p&gt;拷贝并解压缩某个压缩包&lt;/p&gt;
&lt;p&gt;与 add 功能相同，但不能解压缩&lt;/p&gt;
&lt;p&gt;自建容器卷&lt;/p&gt;
&lt;p&gt;指定容器启动时要运行的命令，只有最后一个 CMD 命令生效&lt;/p&gt;
&lt;p&gt;指定容器启动时要运行的命令，但不会覆盖之前的命令&lt;/p&gt;
&lt;p&gt;触发器&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;Docker%E5%85%A5%E9%97%A8.assets/image-20200411092727338.png&#34; alt=&#34;image-20200411092727338&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CMD 和 ENTRYPOINT 区别：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CMD  run 命令后加参数覆盖之前的命令&lt;/p&gt;
&lt;p&gt;ENTRYPOINT  run 命令后的参数添加到命令里&lt;/p&gt;
&lt;p&gt;exec：&lt;/p&gt;
&lt;p&gt;在容器外部对容器进行操作&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;dockerfile 总结：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;Docker%E5%85%A5%E9%97%A8.assets/image-20200411102921708.png&#34; alt=&#34;image-20200411102921708&#34;&gt;&lt;/p&gt;
</content>
        <category term="Docker" />
        <updated>2020-09-12T07:59:46.000Z</updated>
    </entry>
</feed>
