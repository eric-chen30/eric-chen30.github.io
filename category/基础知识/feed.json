{
    "version": "https://jsonfeed.org/version/1",
    "title": "CsStar • All posts by \"基础知识\" category",
    "description": "Work Hard To Be A Better Man",
    "home_page_url": "http://csstar.top",
    "items": [
        {
            "id": "http://csstar.top/2020/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/",
            "url": "http://csstar.top/2020/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/",
            "title": "计算机组成原理复习",
            "date_published": "2020-10-03T12:23:32.000Z",
            "content_html": "<h1 id=\"重点知识点\"><a class=\"markdownIt-Anchor\" href=\"#重点知识点\">#</a> 重点知识点</h1>\n<p>IEEE754 标准的 32/64 位浮点数的表示方法、补码的加减运算、双符号位运算判断是否溢出、指令格式的设计、存储器的扩展问题、静态存储图、SRAM 结构图、cache 的相关计算、寻址方式、CPU 模型、指令周期、双总线数据通路、指令周期流程图、ALU 运算器的结构图、微指令格式设计、微程序控制器、流水线时空图以及一些相关计算（吞吐率，加速比）、总线带宽、磁盘计算、刷新存储器、中断原理。</p>\n<h1 id=\"cache的相关计算\"><a class=\"markdownIt-Anchor\" href=\"#cache的相关计算\">#</a> cache 的相关计算</h1>\n<ol>\n<li>\n<p>命中率 H = 访问 cache 的次数 /（访问 cache 次数 + 访问主存的次数）</p>\n</li>\n<li>\n<p>平均访问时间 t=H✖访问 cache 的平均时间 +（1-H）✖访问主存的平均时间</p>\n</li>\n<li>\n<p>主存慢于 cache 的倍率 r = 访问主存平均的时间 / 访问 cache 的平均时间</p>\n</li>\n<li>\n<p>访问频率 e=t（c）/  t（a） =  1/ （r+（1-r）h）</p>\n</li>\n</ol>\n<h1 id=\"磁盘的相关计算\"><a class=\"markdownIt-Anchor\" href=\"#磁盘的相关计算\">#</a> 磁盘的相关计算</h1>\n<ol>\n<li>平均存储时间 = 找道时间 + 等待时间（1/2r） + 数据传输时间（b/rN）</li>\n<li>有效存储区域：外半径 - 内半径</li>\n<li>圆柱面 = 道密度✖有效存储区域</li>\n<li>每道信息量 N：有效道周长✖位密度 D</li>\n<li>每道信息量：每道信息量✖圆柱面</li>\n<li>总存储量：每道信息量✖有效面数</li>\n<li>数据传输率：D（r）=r（转速）✖N（每道信息量）    D（r）=D（位密度）✖ v（线速度）</li>\n</ol>\n<h1 id=\"ieee754标准\"><a class=\"markdownIt-Anchor\" href=\"#ieee754标准\">#</a> IEEE754 标准</h1>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>阶符</th>\n<th>阶码</th>\n<th>数值位</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>32 位浮点数</td>\n<td>1 位</td>\n<td>8 位</td>\n<td>23 位</td>\n</tr>\n<tr>\n<td>64 位浮点数</td>\n<td>1 位</td>\n<td>11 位</td>\n<td>52 位</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>注意：阶码用移码来表示，其中 32 位在指数的基础上加上 127，64 位在指数的基础上加上 1023</p>\n</blockquote>\n<h1 id=\"补码加减法\"><a class=\"markdownIt-Anchor\" href=\"#补码加减法\">#</a> 补码加减法</h1>\n<blockquote>\n<p>正数的补码是本身，负数的补码是符号位不变，数值为取反，末尾加一；</p>\n<p>符号的最高位进位应该丢弃；</p>\n<p>采用双符号位补码运算可确定是否溢出；</p>\n<p>y 的补码求 - y 补码的原则：包含符号位取反末尾加一；</p>\n</blockquote>\n<p>公式：</p>\n<p>x 的补码 + y 的补码 =  （x+y）的补码</p>\n<p>x 的补码 - y 的补码   = x 的补码 + （-y）的补码 = （x-y）的补码</p>\n<h1 id=\"机器的指令格式\"><a class=\"markdownIt-Anchor\" href=\"#机器的指令格式\">#</a> 机器的指令格式</h1>\n<table>\n<thead>\n<tr>\n<th>操作码</th>\n<th>寻址位</th>\n<th>数据域</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>与指令的数量有关</td>\n<td>与寻址方式的数量有关</td>\n<td>机器字长减去前面两个域的位数</td>\n</tr>\n</tbody>\n</table>\n<p>以上是单地址的表示方法，还有双地址，三地址的表示方法。</p>\n<h1 id=\"主存地址格式\"><a class=\"markdownIt-Anchor\" href=\"#主存地址格式\">#</a> 主存地址格式</h1>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>第一个域</th>\n<th>第二个域</th>\n<th>第三个域</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>直接映射方式</td>\n<td>标记（s-r）</td>\n<td>行号 r</td>\n<td>字地址 w</td>\n</tr>\n<tr>\n<td>组相联映射方式</td>\n<td>标记（s-d）</td>\n<td>组号 d</td>\n<td>字地址 w</td>\n</tr>\n<tr>\n<td>全相联映射方式</td>\n<td>标记 s</td>\n<td>字地址 w</td>\n<td>无，只有两个域</td>\n</tr>\n</tbody>\n</table>\n<p>解释：</p>\n<ol>\n<li>w 的计算：与块的大小有关</li>\n<li>d 的计算：组数    （cache 的行数 = 组数✖每组的行数）</li>\n<li>s 的计算：与主存的块数有关</li>\n<li>主存地址的长度：（s+w）</li>\n<li>主存寻址单元数 + 主存容量：2 的（s+w）次方</li>\n</ol>\n<blockquote>\n<p>单位的换算：1MB  = 2 的 20 次方 B     1KB = 2 的 10 次方 B</p>\n<p>同时注意 B 和 b 的区别，前者为字节，后者为比特，一个字节等于八个比特</p>\n</blockquote>\n<h1 id=\"存储器存储信息\"><a class=\"markdownIt-Anchor\" href=\"#存储器存储信息\">#</a> 存储器存储信息</h1>\n<p>存储位元总数：存储器容量（2 的地址位）✖存储器的字长</p>\n<p>如：16 位地址，32 位字长的 RAM 存储器</p>\n<p>存储容量为：2 的 16 次方✖2 的 5 次方 / 8  = 2 的 18 次方个字节</p>\n<h1 id=\"流水cpu\"><a class=\"markdownIt-Anchor\" href=\"#流水cpu\">#</a> 流水 CPU</h1>\n<p>同一个处理机同一时间只能处理一个程序。</p>\n<p>吞吐率（每秒钟执行完毕的指令条数） =  总指令条数 / 总时间</p>\n<p>加速比：非流水 CPU 所耗的时间 /  流水 CPU 耗时</p>\n<h1 id=\"微指令格式\"><a class=\"markdownIt-Anchor\" href=\"#微指令格式\">#</a> 微指令格式</h1>\n<table>\n<thead>\n<tr>\n<th>操作控制 OP</th>\n<th>测试字段 P</th>\n<th>地址字段 A</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>操作控制</td>\n<td>顺序控制</td>\n<td>顺序控制</td>\n</tr>\n</tbody>\n</table>\n<p>控存容量：1024✖64 位 —&gt; 地址字段有 10 位</p>\n<p>测试字段的位数：与控制转移条件的个数有关</p>\n<p>操作控制字段：微指令字长减去上面两个字段所占的位数</p>\n<blockquote>\n<p>控制存储器：只读存储器，存放全部指令系统的微程序；</p>\n<p>微指令寄存器：微命令寄存器，负责存放 P 字段和控制字段。微地址寄存器，存放下一条微指令的地址信息。</p>\n<p>地址转移逻辑：微程序出现分支时，根据测试标志的状态，去对微地址寄存器中的内容进行修改。</p>\n</blockquote>\n<h1 id=\"中断\"><a class=\"markdownIt-Anchor\" href=\"#中断\">#</a> 中断</h1>\n<p>定义：</p>\n<blockquote>\n<p>子程序的数据准备就绪时，向 CPU 发送请求中断的信号。（我理解的是请求暂时中断主程序，来服务子程序，子程序处理完后，返回主程序继续执行）</p>\n</blockquote>\n<p>注意：</p>\n<blockquote>\n<ul>\n<li>向 CPU 发送中断信号的同时，同时将 “中断屏蔽触发器” 置为 1，关闭中断请求，防止其它程序中断请求</li>\n<li>处理完子程序，“中断屏蔽触发器” 置为 0，开放，便于其它子程序发送中断请求信号</li>\n</ul>\n</blockquote>\n<p>其它概念:</p>\n<blockquote>\n<p>保护现场：将 PC 内容、CPU 状态等保存到堆栈中；</p>\n<p>四个标志触发器：RD（准备就绪）、EI（允许中断触发器）、IR（中断寄存器）、IM（中断屏蔽触发器）；</p>\n<p>单级中断 / 多级中断</p>\n</blockquote>\n<h1 id=\"寻址方式\"><a class=\"markdownIt-Anchor\" href=\"#寻址方式\">#</a> 寻址方式</h1>\n<h2 id=\"指令的寻址方式\"><a class=\"markdownIt-Anchor\" href=\"#指令的寻址方式\">#</a> 指令的寻址方式</h2>\n<blockquote>\n<p>总共有两种：顺序寻址方式和跳跃寻址方式</p>\n</blockquote>\n<h2 id=\"操作数的基本寻址方式\"><a class=\"markdownIt-Anchor\" href=\"#操作数的基本寻址方式\">#</a> 操作数的基本寻址方式</h2>\n<blockquote>\n<p>隐含寻址、立即寻址、直接寻址、间接寻址、寄存器寻址、寄存器间接寻址、偏移寻址、堆栈寻址。</p>\n</blockquote>\n",
            "tags": [
                "计算机组成原理"
            ]
        }
    ]
}