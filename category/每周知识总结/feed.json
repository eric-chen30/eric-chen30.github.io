{
    "version": "https://jsonfeed.org/version/1",
    "title": "CsStar • All posts by \"每周知识总结\" category",
    "description": "Work Hard To Be A Better Man",
    "home_page_url": "http://csstar.top",
    "items": [
        {
            "id": "http://csstar.top/2020/09/27/%E7%AC%AC%E5%9B%9B%E5%91%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/",
            "url": "http://csstar.top/2020/09/27/%E7%AC%AC%E5%9B%9B%E5%91%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/",
            "title": "第四周知识点总结",
            "date_published": "2020-09-27T01:28:06.000Z",
            "content_html": "<h1 id=\"关于博客插入图片\"><a class=\"markdownIt-Anchor\" href=\"#关于博客插入图片\">#</a> 关于博客插入图片</h1>\n<h2 id=\"遇到的问题\"><a class=\"markdownIt-Anchor\" href=\"#遇到的问题\">#</a> 遇到的问题</h2>\n<p>如果是阿里云服务器，你使用本地的图片路径，远端服务器是访问不到的。这和在 github 上部署有些不一样，因为你可以新建一个 images 文件专门用来存放图片，github 可以访问得到。</p>\n<h2 id=\"解决办法\"><a class=\"markdownIt-Anchor\" href=\"#解决办法\">#</a> 解决办法</h2>\n<p>使用图床来实现图片的加载，我就用自己的话说一下图床。</p>\n<blockquote>\n<p>图床：你把本地图片上传到一个云存储里，然后这个云存储会把这些图片自动生成网页链接，于是你就可以通过网络链接来访问这些图片，相当于你博客引用的图片就是引用网上的图片，这样远端服务器就可以访问的到。</p>\n</blockquote>\n<h2 id=\"添加图片链接的格式\"><a class=\"markdownIt-Anchor\" href=\"#添加图片链接的格式\">#</a> 添加图片链接的格式</h2>\n<ul>\n<li>\n<p>！[描述信息] (图片链接 )</p>\n</li>\n<li>\n<p>img 标签 + src（图片链接）+alt（描述信息）</p>\n</li>\n</ul>\n<h2 id=\"data-src与src属性\"><a class=\"markdownIt-Anchor\" href=\"#data-src与src属性\">#</a> data-src 与 src 属性</h2>\n<p>img 标签如果只有 data-src 属性，是无法实现图片的显示的，它是图片懒加载的标志，负责存储照片的信息，只有同时存在 src 属性，才会把 data-src 中存储的图片信息赋值给 src，最终实现图片的实现。</p>\n<h1 id=\"进程的几种状态\"><a class=\"markdownIt-Anchor\" href=\"#进程的几种状态\">#</a> 进程的几种状态</h1>\n<h2 id=\"三种基本状态\"><a class=\"markdownIt-Anchor\" href=\"#三种基本状态\">#</a> 三种基本状态</h2>\n<blockquote>\n<p>准备状态，运行状态，就绪状态</p>\n</blockquote>\n<ul>\n<li>就绪状态：一个进程获得了除处理机外的一切资源，只要被调度，就会由就绪状态变为运行状态。</li>\n<li>运行状态：一个进程在处理机上运行。</li>\n<li>阻塞状态：正在执行的进程，由于等待某个事件发生而无法执行时，放弃处理机便处于阻塞状态。例如：等待 I/O 完成、申请缓冲区不能满足、等待信号等。</li>\n</ul>\n<h2 id=\"进程状态的变迁\"><a class=\"markdownIt-Anchor\" href=\"#进程状态的变迁\">#</a> 进程状态的变迁</h2>\n<blockquote>\n<ol>\n<li>就绪 —&gt; 执行</li>\n</ol>\n</blockquote>\n<p>处于就绪的进曾，一旦被分配了处理机，配可以转换为执行状态。</p>\n<blockquote>\n<ol start=\"2\">\n<li>执行 —&gt; 就绪</li>\n</ol>\n</blockquote>\n<p>执行状态的进程所分配的时间片用完了，就不得不让出处理机，但同时又是非自愿推出执行状态，因此处于就绪队列，等待处理机处理。</p>\n<blockquote>\n<ol start=\"3\">\n<li>执行 —&gt; 阻塞</li>\n</ol>\n</blockquote>\n<p>正在执行的进程因为等待某件事情的执行结果而无法继续执行。</p>\n<blockquote>\n<ol start=\"4\">\n<li>阻塞 —&gt; 就绪</li>\n</ol>\n</blockquote>\n<p>处于阻塞状态的进程，若其等待的事情已经发生，进程便由阻塞态转变为就绪态。</p>\n<h2 id=\"阻塞状态和等待状态\"><a class=\"markdownIt-Anchor\" href=\"#阻塞状态和等待状态\">#</a> 阻塞状态和等待状态</h2>\n<p>阻塞时被动的阻塞，一个线程去争抢一个内部对象的锁，但是此时这个锁被其他线程所持有，那么该线程就会进入阻塞状态，也就是单例模式中，多个线程同时争抢锁，没有抢到锁的那个线程的状态。</p>\n<blockquote>\n<p>线程和别的线程争抢锁没有抢到，就处于阻塞状态；（此时线程还没有进入同步代码块）</p>\n<p>线程抢到了锁进入同步代码块，某些条件下，就处于等待状态。</p>\n</blockquote>\n<h1 id=\"操作系统的基本知识\"><a class=\"markdownIt-Anchor\" href=\"#操作系统的基本知识\">#</a> 操作系统的基本知识</h1>\n<ol>\n<li>一个字节 = 8bit</li>\n<li>发送延时 = 数据帧的长度 / 发送速率</li>\n<li>传播延时 = 信道长度 / 电磁波在信道上的传播速率</li>\n<li>除了发送和传播延时，还有处理延时和排队延时</li>\n<li>总延时 = 发送延时 + 传播延时 + 处理延时 + 排队延时</li>\n</ol>\n",
            "tags": [
                "小的知识点"
            ]
        }
    ]
}