<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://csstar.top</id>
    <title>CsStar • Posts by &#34;计算机基础&#34; category</title>
    <link href="http://csstar.top" />
    <updated>2022-03-16T15:11:34.000Z</updated>
    <category term="Docker" />
    <category term="ES7-11" />
    <category term="Pandas" />
    <category term="快捷操作" />
    <category term="前端学习网站" />
    <category term="前端知识" />
    <category term="计算机网络" />
    <category term="DOM" />
    <category term="计算机组成原理" />
    <category term="设计模式" />
    <category term="浏览器" />
    <category term="ES6" />
    <entry>
        <id>http://csstar.top/2022/03/16/%E7%BD%91%E7%BB%9C/</id>
        <title>网络</title>
        <link rel="alternate" href="http://csstar.top/2022/03/16/%E7%BD%91%E7%BB%9C/"/>
        <content type="html">&lt;h2 id=&#34;tcp-vs-udp&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#tcp-vs-udp&#34;&gt;#&lt;/a&gt; &lt;strong&gt;TCP vs  UDP&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;TCP   面向连接的、可靠的、基于字节流的传输层通信协议&lt;/li&gt;
&lt;li&gt;UDP   提供简单不可靠的非连接传输服务，面向报文&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;code&gt;TCP&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;UDP&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;面向连接的，可靠性高&lt;/td&gt;
&lt;td&gt;非连接的，可靠性低&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;基于三次握手，信息有延时，时效性较差&lt;/td&gt;
&lt;td&gt;时效性好，常用于实时传输&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;首部开销 20 字节，如果携带的用户数据较小，则利用率低&lt;/td&gt;
&lt;td&gt;首部开销 8 字节，可以传输更多的用户数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;端对端的，有序号机制、确认机制、超时重传机制，确保数据可靠交付&lt;/td&gt;
&lt;td&gt;一对一、一对多、多对一、多对多的交互通信&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FTP（应用层协议）基于 TCP&lt;/td&gt;
&lt;td&gt;DNS（应用层协议）基于 UDP&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;xss-跨网站指令码&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#xss-跨网站指令码&#34;&gt;#&lt;/a&gt; XSS: 跨网站指令码&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;反射型&lt;/li&gt;
&lt;li&gt;存储型&lt;/li&gt;
&lt;li&gt;DOM-based 型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如何攻击：通过修改 HTML 节点或者运行 JS 脚本进行攻击&lt;/p&gt;
&lt;p&gt;如何防御：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;最普遍的做法是对输入输出的内容进行转义，对于引号、尖括号、斜杠进行转义。  如果有特定的文本不能进行转义，需要设置黑白名单来进行过滤&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CSP: 内容安全策略     本质上也是建立白名单，规定浏览器只能够执行特定来源的代码   通过设置  &lt;code&gt;HTTP Header中的Content-Security-Policy 来开启CSP&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;只允许加载本站资源&lt;/li&gt;
&lt;li&gt;只允许加载 https 协议的图片&lt;/li&gt;
&lt;li&gt;允许加载任何来源框架&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;csrf跨站请求伪造-是一种挟持用户在已经登录的web应用程序上执行非本意操作的攻击方法&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#csrf跨站请求伪造-是一种挟持用户在已经登录的web应用程序上执行非本意操作的攻击方法&#34;&gt;#&lt;/a&gt; CSRF：跨站请求伪造    是一种挟持用户在已经登录的 web 应用程序上执行非本意操作的攻击方法&lt;/h2&gt;
&lt;p&gt;如何防御：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;get 请求不对数据进行修改&lt;/li&gt;
&lt;li&gt;不让第三方网站访问到用户的 Cookie                       对 cookie 设置 Samesite 属性，该属性设置 cookie 不随着跨域请求发送&lt;/li&gt;
&lt;li&gt;阻止第三方网站请求接口                                       验证 Referer 来判断请求是否由第三方网站发起的&lt;/li&gt;
&lt;li&gt;请求时附带验证信息，比如验证码或者 Cookie           服务器下发一个随机的 Token，每次用户发送请求的时候，必须携带这个 Token，然后服务器对其进行检验&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;密码安全&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#密码安全&#34;&gt;#&lt;/a&gt; 密码安全&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;加盐：对于密码存储来说，必然是不能明文存储在数据库中，不然一旦数据库泄漏，会对用户造成巨大的损失。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加盐就是给原密码添加字符串。加盐后的密码再进行一些列的加密算法处理。&lt;/li&gt;
&lt;li&gt;加盐并不能阻止别人盗取账号，只能确保即使数据库泄漏，也不会暴露用户的真实密码&lt;/li&gt;
&lt;li&gt;通常使用验证码增产时延或者限制尝试次数的方式，并且当输入错误时，不能提示密码输入错误，而是提示账号或者密码输入错误&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;三次握手&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#三次握手&#34;&gt;#&lt;/a&gt; 三次握手&lt;/h2&gt;
&lt;p&gt;客户端：closed——》SYN  Send——》established&lt;/p&gt;
&lt;p&gt;服务端：closed——》Listened——》SYN Receive——》established&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么需要三次握手&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果 A 向 B 发送了一个连接请求，由于网络延时原因，这个 A 发送的请求长时间没有被 B 接收，就会触发超时重传机制，重新发送的请求被 B 接收到后，两者顺利建立连接并开始传输信息或者数据，然后连接结束，两者处于 closed 状态。但此时，之前由于网络延时而未到达的请求到达了 B，B 以为 A 又要建立新的连接，便应答了请求，从而处于 established 状态，而此时 A 是 closed 状态，那么服务器就会一直等客户端传输数据，会造成资源浪费。&lt;/p&gt;
&lt;h2 id=&#34;四次挥手&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#四次挥手&#34;&gt;#&lt;/a&gt; 四次挥手&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;断开连接时，两端都需要发送 FIN 和 ACK 信号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;客户端：established——》FIN-WAIT-1——》FIN-WAIT-2——》TIME_WAIT——》closed&lt;/p&gt;
&lt;p&gt;服务端：established——》close-wait——》last-ack——》closed&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果客户端 A 认为需要发送的数据已经发送完成，向给服务器 B 发送连接释放的请求&lt;/li&gt;
&lt;li&gt;B 收到释放请求后，会告诉应用层要释放 TCP 连接，然后发送 ACK 包，进入 close-wait 状态，表明 A 到 B 的连接已经释放，不再接收 A 发送的数据。但此时 B 仍然可以发送数据给 A&lt;/li&gt;
&lt;li&gt;B 如果此时还有没发送完的数据继续发送，数据发送完毕后，向 A 发送释放连接请求，然后 B 进入 last-ack 状态&lt;/li&gt;
&lt;li&gt;A 收到请求后，向 B 发送确认应答，此时 A 进入 Time-wait 状态。该状态会持续一个最大生命周期，如果该段时间内没有收到来自 B 的重发请求话，就进入 closed 状态，B 接收到 A 发送的确认信号后，进入 closed 状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么 A 需要等待 2MSL 时间？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了确保 B 能够收到 A 发送的确认断开的信号，因为如果确认信息由于网络问题一直没有到达，就会导致 B 不能正常关闭。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;拥塞处理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;慢开始、拥塞避免&lt;/li&gt;
&lt;li&gt;快速重传、快速恢复&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;get请求和post请求&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#get请求和post请求&#34;&gt;#&lt;/a&gt; get 请求和 post 请求&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;get 请求由于 url 长度的限制导致请求参数有长度限制，而 post 请求没有长度限制&lt;/li&gt;
&lt;li&gt;post 请求相对于 get 请求安全些，因为 get 请求参数都展示在 url 上&lt;/li&gt;
&lt;li&gt;post 可以通过 request body 传输更多的数据，而 get 没有这个技术&lt;/li&gt;
&lt;li&gt;post 支持更多的编码类型且不对数据类型限制&lt;/li&gt;
&lt;li&gt;在前端使用接口编写参数的时候，post 对于复杂的请求参数更容易编写&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;常见状态码&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#常见状态码&#34;&gt;#&lt;/a&gt; 常见状态码&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;2xx  成功&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;200 ok 表示客户端发送的请求被服务器正常处理&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;204 no content  表示请求成功，但是响应报文不包含实体的主体部分&lt;/li&gt;
&lt;li&gt;205 reset content  与 204 一样，但是要求请求方重置内容&lt;/li&gt;
&lt;li&gt;206 partial Content   进行范围请求&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3xx 重定向&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;301 moved  permanently    永久性重定向，表示资源已经被分配到新的url&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;302 found   临时性重定向&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;303   see other  表示资源存在着另一个 URL，应该使用 get 方法请求资源&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;4xx  客户端错误&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;400 bad request  请求报文存在语法错误&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;401 unauthorized  表示发送的请求需要有HTTP认证的认证信息&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;402  forbidden   请求资源被服务器拒绝&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;404  not found   服务器没有找到请求的资源&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;5xx  服务器错误&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;500 internal server error  服务器在执行请求时发生了错误&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;501 not implemented   服务器不支持当前请求的某个功能&lt;/li&gt;
&lt;li&gt;&lt;code&gt;503  service unavailable   服务器此时处于超负载或者正在停机维护，无法处理请求&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;https&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#https&#34;&gt;#&lt;/a&gt; HTTPS&lt;/h2&gt;
&lt;p&gt;HTTPS 还是通过 HTTP 进行信息的传输，但是信息通过 TLS 协议进行了加密。&lt;/p&gt;
&lt;p&gt;TLS 使用了两种加密技术：对称加密和非对称加密。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对称加密指两边具有相同的密钥，两边都知道将密文进行加密解密&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非对称加密，有公钥和私钥之分，公钥所有人都知道，可以将数据用公钥进行加密，但是数据只能用私钥进行解密，而私钥只有发放公钥的一方知道&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一般双方确认通信前使用非对称加密方式，一旦双方确认后，为了提高性能，两端使用对称加密的方式进行通信&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;TLS 握手过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;客户端发送一个随机值，需要的协议以及加密方式&lt;/li&gt;
&lt;li&gt;服务端收到这个随机值，自己也产生一个随机值，根据客户端发来的协议和加密方式进行处理，发送自己的证书&lt;/li&gt;
&lt;li&gt;客户端收到这个证书并检验是否有效，通过后会再产生一个随机值，通过服务端证书的公钥加密这个随机值并发送给服务端（如果服务端需要客户端证书，需要携带）&lt;/li&gt;
&lt;li&gt;服务端收到这个加密的随机值使用私钥进行解密，这时候两端都有三个随机值，可以通过这三个随机值通过约定的加密方式生成密钥，后面的通信使用这个密钥进行加密解密&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;HTTPS 2.0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.x 中，为了性能考虑，我们常常使用精灵图，将小图内联等方式，主要是因为浏览器限制了同一域名下的请求数量，当页面请求的资源过多时，会造成队头阻塞，一些资源需要等待其它资源请求完毕后才能发起请求。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HTTPS 2.0 改进的地方&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;二进制传输 ：  文本传输数据 ——》新的编码方式，数据被分割，采用二进制编码方式&lt;/li&gt;
&lt;li&gt;多路复用 ：     两个概念：帧 和 流   帧是最小的数据单位，多个帧组成数据流   多路复用就是在一个 TCP 连接中可以存在多条流，解决了队头阻塞的问题&lt;/li&gt;
&lt;li&gt;Header 压缩 ：  在之前的版本中，使用文本形式传输 headers  且携带 cookie 的情况下，每次都要重复传输大量字节   2.0 中使用了 HPACK 对传输的 header 进行压缩，并在两端维护了索引表，用于记录出现过的 headers，后面传输过程中，就只需要穿记录的 haders 的键名，服务端收到键名后可以找到对应的值&lt;/li&gt;
&lt;li&gt;服务端 PUSH  ：服务端在收到客户端的请求后，主动推送一些其它资源&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;dns&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#dns&#34;&gt;#&lt;/a&gt; DNS&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;将域名解析为 IP 的过程，查询过程主要有：迭代查询和递归查询（比较少用）两种&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;迭代查询过程&lt;/strong&gt;（本地域名服务器向根域名服务器的查询采用迭代查询）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户机向本地域名服务器发送 DNS 请求报文（递归查询）&lt;/li&gt;
&lt;li&gt;本地域名服务器收到请求后，查询本地缓存，如果没有记录，以 DNS 客户的身份向根域名服务器发送请求&lt;/li&gt;
&lt;li&gt;根域名服务器收到请求后，判断该域名为.com 域，并将顶级域名服务器 dns.com 的 ip 地址返回给本地域名服务器&lt;/li&gt;
&lt;li&gt;本地域名服务器向顶级域名服务器 dns.com 发送 DNS 请求（迭代查询）&lt;/li&gt;
&lt;li&gt;顶级域名服务器收到请求后，判断该域属于 abc.com 域，因此将对应的授权域名服务器 dns.abc.com 的 IP 地址返回给本地域名服务器&lt;/li&gt;
&lt;li&gt;本地域名服务器向授权域名服务器发送请求&lt;/li&gt;
&lt;li&gt;授权域名服务器收到请求后，将查询结果返回给本地域名服务器&lt;/li&gt;
&lt;li&gt;本地域名服务器将查询结果保存到本地缓存后，同时返回给客户机&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;总结：客户机 ——》本地域名服务器 ——》根域名服务器 ——》本地域名服务器 ——》顶级域名服务器 ——》本地域名服务器 ——》授权域名服务器 ——》本地域名服务器 ——》主机&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;地址栏输入 URL 到页面加载完成的过程&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;DNS 查询，返回 IP 地址（DNS 查询 IP 的过程）&lt;/li&gt;
&lt;li&gt;TCP 握手（TCP 握手过程）&lt;/li&gt;
&lt;li&gt;TLS 握手，然后开始正式的数据传输（TLS 握手过程）&lt;/li&gt;
&lt;li&gt;数据进入服务端之前，可能会经过负责负载均衡的服务器（将请求合理的分发到多台服务器上），假设服务端响应一个 HTML 文件&lt;/li&gt;
&lt;li&gt;首先，浏览器会判断状态码，如果是 200 继续解析，如果是 400（客户端请求数据出现错误）或者 500（浏览器处理请求错误）会报错，如果是 300 的话，会进行重定向，这里会有个重定向计时器，避免多次重定向，超多一定的次数也会报错&lt;/li&gt;
&lt;li&gt;浏览器开始解析 HTML 文件，如果是 gzip 格式还需要先进行解压，通过文件的编码方式得知如何去解压这个文件&lt;/li&gt;
&lt;li&gt;文件解码成功后，开始正式的渲染流程。根据 HTML 构造 DOM 树，根据 CSS 构建 CSSOM 树。如果遇到 script 标签，会检查是否包含 &lt;code&gt;async&lt;/code&gt;  和 &lt;code&gt;defer&lt;/code&gt; ，前者会并行下载执行 JS，后者会先下载文件，然后等 HTML 解析完成后顺序执行，如果上述两种属性都没有，就会阻塞渲染流程，知道 JS 代码加载完毕，引入外部资源需要下载，如果资源比较多，长时间的下载，会阻塞页面的渲染流程，导致页面长时间没有响应。&lt;/li&gt;
&lt;li&gt;初始的 HTML 被完全加载和解析后会触发 DomContentLoaded 事件&lt;/li&gt;
&lt;li&gt;CSSOM 树和 DOM 树构建完成后开始生成 Render 树，同时计算元素的坐标，确定元素的布局&lt;/li&gt;
&lt;li&gt;在 Render 树的过程中，浏览器开始调用 GPU 绘制，将内容展示在屏幕上&lt;/li&gt;
&lt;/ol&gt;
</content>
        <category term="计算机网络" />
        <updated>2022-03-16T15:11:34.000Z</updated>
    </entry>
    <entry>
        <id>http://csstar.top/2020/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/</id>
        <title>计算机组成原理复习</title>
        <link rel="alternate" href="http://csstar.top/2020/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/"/>
        <content type="html">&lt;h1 id=&#34;重点知识点&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#重点知识点&#34;&gt;#&lt;/a&gt; 重点知识点&lt;/h1&gt;
&lt;p&gt;IEEE754 标准的 32/64 位浮点数的表示方法、补码的加减运算、双符号位运算判断是否溢出、指令格式的设计、存储器的扩展问题、静态存储图、SRAM 结构图、cache 的相关计算、寻址方式、CPU 模型、指令周期、双总线数据通路、指令周期流程图、ALU 运算器的结构图、微指令格式设计、微程序控制器、流水线时空图以及一些相关计算（吞吐率，加速比）、总线带宽、磁盘计算、刷新存储器、中断原理。&lt;/p&gt;
&lt;h1 id=&#34;cache的相关计算&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#cache的相关计算&#34;&gt;#&lt;/a&gt; cache 的相关计算&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;命中率 H = 访问 cache 的次数 /（访问 cache 次数 + 访问主存的次数）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;平均访问时间 t=H✖访问 cache 的平均时间 +（1-H）✖访问主存的平均时间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主存慢于 cache 的倍率 r = 访问主存平均的时间 / 访问 cache 的平均时间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;访问频率 e=t（c）/  t（a） =  1/ （r+（1-r）h）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;磁盘的相关计算&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#磁盘的相关计算&#34;&gt;#&lt;/a&gt; 磁盘的相关计算&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;平均存储时间 = 找道时间 + 等待时间（1/2r） + 数据传输时间（b/rN）&lt;/li&gt;
&lt;li&gt;有效存储区域：外半径 - 内半径&lt;/li&gt;
&lt;li&gt;圆柱面 = 道密度✖有效存储区域&lt;/li&gt;
&lt;li&gt;每道信息量 N：有效道周长✖位密度 D&lt;/li&gt;
&lt;li&gt;每道信息量：每道信息量✖圆柱面&lt;/li&gt;
&lt;li&gt;总存储量：每道信息量✖有效面数&lt;/li&gt;
&lt;li&gt;数据传输率：D（r）=r（转速）✖N（每道信息量）    D（r）=D（位密度）✖ v（线速度）&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;ieee754标准&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#ieee754标准&#34;&gt;#&lt;/a&gt; IEEE754 标准&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;阶符&lt;/th&gt;
&lt;th&gt;阶码&lt;/th&gt;
&lt;th&gt;数值位&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;32 位浮点数&lt;/td&gt;
&lt;td&gt;1 位&lt;/td&gt;
&lt;td&gt;8 位&lt;/td&gt;
&lt;td&gt;23 位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;64 位浮点数&lt;/td&gt;
&lt;td&gt;1 位&lt;/td&gt;
&lt;td&gt;11 位&lt;/td&gt;
&lt;td&gt;52 位&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：阶码用移码来表示，其中 32 位在指数的基础上加上 127，64 位在指数的基础上加上 1023&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;补码加减法&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#补码加减法&#34;&gt;#&lt;/a&gt; 补码加减法&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;正数的补码是本身，负数的补码是符号位不变，数值为取反，末尾加一；&lt;/p&gt;
&lt;p&gt;符号的最高位进位应该丢弃；&lt;/p&gt;
&lt;p&gt;采用双符号位补码运算可确定是否溢出；&lt;/p&gt;
&lt;p&gt;y 的补码求 - y 补码的原则：包含符号位取反末尾加一；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;公式：&lt;/p&gt;
&lt;p&gt;x 的补码 + y 的补码 =  （x+y）的补码&lt;/p&gt;
&lt;p&gt;x 的补码 - y 的补码   = x 的补码 + （-y）的补码 = （x-y）的补码&lt;/p&gt;
&lt;h1 id=&#34;机器的指令格式&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#机器的指令格式&#34;&gt;#&lt;/a&gt; 机器的指令格式&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作码&lt;/th&gt;
&lt;th&gt;寻址位&lt;/th&gt;
&lt;th&gt;数据域&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;与指令的数量有关&lt;/td&gt;
&lt;td&gt;与寻址方式的数量有关&lt;/td&gt;
&lt;td&gt;机器字长减去前面两个域的位数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;以上是单地址的表示方法，还有双地址，三地址的表示方法。&lt;/p&gt;
&lt;h1 id=&#34;主存地址格式&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#主存地址格式&#34;&gt;#&lt;/a&gt; 主存地址格式&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;第一个域&lt;/th&gt;
&lt;th&gt;第二个域&lt;/th&gt;
&lt;th&gt;第三个域&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;直接映射方式&lt;/td&gt;
&lt;td&gt;标记（s-r）&lt;/td&gt;
&lt;td&gt;行号 r&lt;/td&gt;
&lt;td&gt;字地址 w&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;组相联映射方式&lt;/td&gt;
&lt;td&gt;标记（s-d）&lt;/td&gt;
&lt;td&gt;组号 d&lt;/td&gt;
&lt;td&gt;字地址 w&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;全相联映射方式&lt;/td&gt;
&lt;td&gt;标记 s&lt;/td&gt;
&lt;td&gt;字地址 w&lt;/td&gt;
&lt;td&gt;无，只有两个域&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;解释：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;w 的计算：与块的大小有关&lt;/li&gt;
&lt;li&gt;d 的计算：组数    （cache 的行数 = 组数✖每组的行数）&lt;/li&gt;
&lt;li&gt;s 的计算：与主存的块数有关&lt;/li&gt;
&lt;li&gt;主存地址的长度：（s+w）&lt;/li&gt;
&lt;li&gt;主存寻址单元数 + 主存容量：2 的（s+w）次方&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;单位的换算：1MB  = 2 的 20 次方 B     1KB = 2 的 10 次方 B&lt;/p&gt;
&lt;p&gt;同时注意 B 和 b 的区别，前者为字节，后者为比特，一个字节等于八个比特&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;存储器存储信息&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#存储器存储信息&#34;&gt;#&lt;/a&gt; 存储器存储信息&lt;/h1&gt;
&lt;p&gt;存储位元总数：存储器容量（2 的地址位）✖存储器的字长&lt;/p&gt;
&lt;p&gt;如：16 位地址，32 位字长的 RAM 存储器&lt;/p&gt;
&lt;p&gt;存储容量为：2 的 16 次方✖2 的 5 次方 / 8  = 2 的 18 次方个字节&lt;/p&gt;
&lt;h1 id=&#34;流水cpu&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#流水cpu&#34;&gt;#&lt;/a&gt; 流水 CPU&lt;/h1&gt;
&lt;p&gt;同一个处理机同一时间只能处理一个程序。&lt;/p&gt;
&lt;p&gt;吞吐率（每秒钟执行完毕的指令条数） =  总指令条数 / 总时间&lt;/p&gt;
&lt;p&gt;加速比：非流水 CPU 所耗的时间 /  流水 CPU 耗时&lt;/p&gt;
&lt;h1 id=&#34;微指令格式&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#微指令格式&#34;&gt;#&lt;/a&gt; 微指令格式&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作控制 OP&lt;/th&gt;
&lt;th&gt;测试字段 P&lt;/th&gt;
&lt;th&gt;地址字段 A&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;操作控制&lt;/td&gt;
&lt;td&gt;顺序控制&lt;/td&gt;
&lt;td&gt;顺序控制&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;控存容量：1024✖64 位 —&amp;gt; 地址字段有 10 位&lt;/p&gt;
&lt;p&gt;测试字段的位数：与控制转移条件的个数有关&lt;/p&gt;
&lt;p&gt;操作控制字段：微指令字长减去上面两个字段所占的位数&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;控制存储器：只读存储器，存放全部指令系统的微程序；&lt;/p&gt;
&lt;p&gt;微指令寄存器：微命令寄存器，负责存放 P 字段和控制字段。微地址寄存器，存放下一条微指令的地址信息。&lt;/p&gt;
&lt;p&gt;地址转移逻辑：微程序出现分支时，根据测试标志的状态，去对微地址寄存器中的内容进行修改。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;中断&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#中断&#34;&gt;#&lt;/a&gt; 中断&lt;/h1&gt;
&lt;p&gt;定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;子程序的数据准备就绪时，向 CPU 发送请求中断的信号。（我理解的是请求暂时中断主程序，来服务子程序，子程序处理完后，返回主程序继续执行）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;向 CPU 发送中断信号的同时，同时将 “中断屏蔽触发器” 置为 1，关闭中断请求，防止其它程序中断请求&lt;/li&gt;
&lt;li&gt;处理完子程序，“中断屏蔽触发器” 置为 0，开放，便于其它子程序发送中断请求信号&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;其它概念:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;保护现场：将 PC 内容、CPU 状态等保存到堆栈中；&lt;/p&gt;
&lt;p&gt;四个标志触发器：RD（准备就绪）、EI（允许中断触发器）、IR（中断寄存器）、IM（中断屏蔽触发器）；&lt;/p&gt;
&lt;p&gt;单级中断 / 多级中断&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;寻址方式&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#寻址方式&#34;&gt;#&lt;/a&gt; 寻址方式&lt;/h1&gt;
&lt;h2 id=&#34;指令的寻址方式&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#指令的寻址方式&#34;&gt;#&lt;/a&gt; 指令的寻址方式&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;总共有两种：顺序寻址方式和跳跃寻址方式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;操作数的基本寻址方式&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#操作数的基本寻址方式&#34;&gt;#&lt;/a&gt; 操作数的基本寻址方式&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;隐含寻址、立即寻址、直接寻址、间接寻址、寄存器寻址、寄存器间接寻址、偏移寻址、堆栈寻址。&lt;/p&gt;
&lt;/blockquote&gt;
</content>
        <category term="计算机组成原理" />
        <updated>2020-10-03T12:23:32.000Z</updated>
    </entry>
    <entry>
        <id>http://csstar.top/2020/09/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
        <title>设计模式之单例模式</title>
        <link rel="alternate" href="http://csstar.top/2020/09/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
        <content type="html">&lt;h1 id=&#34;概括&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#概括&#34;&gt;#&lt;/a&gt; 概括&lt;/h1&gt;
&lt;h2 id=&#34;定义&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#定义&#34;&gt;#&lt;/a&gt; 定义&lt;/h2&gt;
&lt;p&gt;单例模式指在内存中只会创建一次且仅创建一次对象的模式。&lt;/p&gt;
&lt;h2 id=&#34;原因&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#原因&#34;&gt;#&lt;/a&gt; 原因&lt;/h2&gt;
&lt;p&gt;该模式是为了防止创建多个对象造成的资源浪费和管理困难的问题，仅在内存中创建一个对象，让有需要调用的地方都使用这一个单例对象。&lt;/p&gt;
&lt;h2 id=&#34;两种模式&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#两种模式&#34;&gt;#&lt;/a&gt; 两种模式&lt;/h2&gt;
&lt;p&gt;饿汉式：只有在需要调用对象的时候采取调用单例对象。&lt;/p&gt;
&lt;p&gt;懒汉式：类加载的时候就已经创建好了单例对象，随时等待调用。&lt;/p&gt;
&lt;h1 id=&#34;使用方法&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#使用方法&#34;&gt;#&lt;/a&gt; 使用方法&lt;/h1&gt;
&lt;h2 id=&#34;懒汉式&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#懒汉式&#34;&gt;#&lt;/a&gt; 懒汉式：&lt;/h2&gt;
&lt;p&gt;当程序需要使用对象的时候，先判断对象是否已经实例化，如果没有，则实例化对象，如果已经实例化，则直接返回对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示意图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://qh82kvit3.hn-bkt.clouddn.com/clipboard-1601039788093.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实例代码：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://qh82kvit3.hn-bkt.clouddn.com/clipboard-1601039836972.png&#34; alt=&#34;avatar&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;饿汉模式&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#饿汉模式&#34;&gt;#&lt;/a&gt; 饿汉模式&lt;/h2&gt;
&lt;p&gt;类加载的时候直接创建单例对象，当需要调用时，直接使用这个已经创建好的单例对象就行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示意图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://qh82kvit3.hn-bkt.clouddn.com/clipboard-1601039865541.png&#34; alt=&#34;avatar&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例代码：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://qh82kvit3.hn-bkt.clouddn.com/clipboard-1601039888935.png&#34; alt=&#34;avatar&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类在加载的时候会在内存中实例化一个对象，当类被撤除时，这个对象也会随之消失。&lt;/p&gt;
&lt;h1 id=&#34;改进和优化&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#改进和优化&#34;&gt;#&lt;/a&gt; 改进和优化&lt;/h1&gt;
&lt;h2 id=&#34;懒汉模式的优化&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#懒汉模式的优化&#34;&gt;#&lt;/a&gt; 懒汉模式的优化&lt;/h2&gt;
&lt;p&gt;问题 1：如果两个线程同时判断不存在已经实例化的对象，那么这两个线程都会实例化对象，就产生了两个对象，不符合单例模式。这里涉及到线程并发的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示意图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://qh82kvit3.hn-bkt.clouddn.com/clipboard-1601039901878.png&#34; alt=&#34;avatar&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案 1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在方法上或类对象上加锁&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;synchronized 的解释：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同步代码块中的锁，当有一个线程执行同步代码时，别的线程就不能执行此代码块。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例代码：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://qh82kvit3.hn-bkt.clouddn.com/clipboard-1601039914173.png&#34; alt=&#34;avatar&#34;&gt;&lt;/p&gt;
&lt;p&gt;问题 2：以上很好地解决了多个线程可能同时创建多个对象的情况，但是，每次去获取对象的时候都要先获取锁，并发性能非常的差，可能情况下，会出现卡帧的情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案 2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;性能优化。如果还没有实例化对象，就需要先获取锁，一旦对象已经实例化后，就可以省去获取锁的过程。所以不能直接在方法上加锁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例代码：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://qh82kvit3.hn-bkt.clouddn.com/clipboard-1601039929391.png&#34; alt=&#34;avatar&#34;&gt;&lt;/p&gt;
&lt;p&gt;因此，解决了线程并发和性能优化的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解释：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;【1】，第一个分支判断是否已经实例化对象，如果已经实例化，则直接返回对象，如果没有的话，就会进入下一个分支。&lt;/p&gt;
&lt;p&gt;【2】，多个线程获取争抢同一个锁，第一个获取锁的线程，就获取了判断的资格，会判断是否有其他线程已经实例化对象了，如果没有，就会实例化一个对象。也因此有了第一个且唯一的对象，当其他进程再次进行判断时，已经有了对象，就会直接返回实例化的对象，而不会再去创建对象。&lt;/p&gt;
&lt;p&gt;【3】懒汉模式可总结为：双重校验 + 锁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;完整代码：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://qh82kvit3.hn-bkt.clouddn.com/clipboard-1601039941802.png&#34; alt=&#34;avatar&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;volatile 防止指令重排：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建一个对象，在 JVM 中会经过三步：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）为 singleehan 分配内存空间&lt;/p&gt;
&lt;p&gt;（2）初始化 singleehan 对象&lt;/p&gt;
&lt;p&gt;（3）将 singleehan 指向分配好的内存空间&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;指令重排序：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JVM 在保证最终结果正确的情况下，可以不按照程序编码的顺序执行语句，仅可能提高程序的性能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://qh82kvit3.hn-bkt.clouddn.com/clipboard-1601039959416.png&#34; alt=&#34;avatar&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;volatile 的作用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 volatile 关键字修饰的变量，可以保证其指令执行的顺序与程序指明的顺序一致，不会发生顺序变换，这样在多线程环境下就不会发生 NPE 异常了。volatile 还有第二个作用：使用 volatile 关键字修饰的变量，可以保证其内存可见性，即每一时刻线程读取到该变量的值都是内存中最新的那个值，线程每次操作该变量都需要先读取该变量。&lt;/p&gt;
&lt;p&gt;因此，会需要对上述代码进行如下改进：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://qh82kvit3.hn-bkt.clouddn.com/clipboard.png&#34; alt=&#34;avatar&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目的：为了防止指令重排导致的 NPE 异常。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;总结&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#总结&#34;&gt;#&lt;/a&gt; 总结&lt;/h1&gt;
&lt;p&gt;1，单例模式有两种类型：懒汉式和饿汉式。&lt;/p&gt;
&lt;p&gt;2，懒汉式：只有需要调用的时候才回去创建对象，实现方法：双重校验 + 锁 + volatile 防止指令重排&lt;/p&gt;
&lt;p&gt;3，饿汉式：类加载的时候就会初始化实例对象，等待着被调用。不存在并发和性能的问题。&lt;/p&gt;
&lt;p&gt;4，如果对于内存要求不高，那么就是用饿汉式，好处是不容易出错；如果对于内存的要求很高，就是用懒汉式。&lt;/p&gt;
&lt;p&gt;5，为了防止多线程环境下，因为指令重排序导致变量报 NPE，需要在单例对象上添加 volatile 关键字防止指令重排序。&lt;/p&gt;
</content>
        <category term="设计模式" />
        <updated>2020-09-21T11:07:10.000Z</updated>
    </entry>
</feed>
