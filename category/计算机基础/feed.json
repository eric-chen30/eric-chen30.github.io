{
    "version": "https://jsonfeed.org/version/1",
    "title": "CsStar • All posts by \"计算机基础\" category",
    "description": "Work Hard To Be A Better Man",
    "home_page_url": "http://csstar.top",
    "items": [
        {
            "id": "http://csstar.top/2022/03/16/%E7%BD%91%E7%BB%9C/",
            "url": "http://csstar.top/2022/03/16/%E7%BD%91%E7%BB%9C/",
            "title": "网络",
            "date_published": "2022-03-16T15:11:34.000Z",
            "content_html": "<h2 id=\"tcp-vs-udp\"><a class=\"markdownIt-Anchor\" href=\"#tcp-vs-udp\">#</a> <strong>TCP vs  UDP</strong></h2>\n<ul>\n<li>TCP   面向连接的、可靠的、基于字节流的传输层通信协议</li>\n<li>UDP   提供简单不可靠的非连接传输服务，面向报文</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><code>TCP</code></th>\n<th><code>UDP</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>面向连接的，可靠性高</td>\n<td>非连接的，可靠性低</td>\n</tr>\n<tr>\n<td>基于三次握手，信息有延时，时效性较差</td>\n<td>时效性好，常用于实时传输</td>\n</tr>\n<tr>\n<td>首部开销 20 字节，如果携带的用户数据较小，则利用率低</td>\n<td>首部开销 8 字节，可以传输更多的用户数据</td>\n</tr>\n<tr>\n<td>端对端的，有序号机制、确认机制、超时重传机制，确保数据可靠交付</td>\n<td>一对一、一对多、多对一、多对多的交互通信</td>\n</tr>\n<tr>\n<td>FTP（应用层协议）基于 TCP</td>\n<td>DNS（应用层协议）基于 UDP</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"xss-跨网站指令码\"><a class=\"markdownIt-Anchor\" href=\"#xss-跨网站指令码\">#</a> XSS: 跨网站指令码</h2>\n<ul>\n<li>反射型</li>\n<li>存储型</li>\n<li>DOM-based 型</li>\n</ul>\n<p>如何攻击：通过修改 HTML 节点或者运行 JS 脚本进行攻击</p>\n<p>如何防御：</p>\n<ul>\n<li>\n<p>最普遍的做法是对输入输出的内容进行转义，对于引号、尖括号、斜杠进行转义。  如果有特定的文本不能进行转义，需要设置黑白名单来进行过滤</p>\n</li>\n<li>\n<p>CSP: 内容安全策略     本质上也是建立白名单，规定浏览器只能够执行特定来源的代码   通过设置  <code>HTTP Header中的Content-Security-Policy 来开启CSP</code></p>\n<ol>\n<li>只允许加载本站资源</li>\n<li>只允许加载 https 协议的图片</li>\n<li>允许加载任何来源框架</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"csrf跨站请求伪造-是一种挟持用户在已经登录的web应用程序上执行非本意操作的攻击方法\"><a class=\"markdownIt-Anchor\" href=\"#csrf跨站请求伪造-是一种挟持用户在已经登录的web应用程序上执行非本意操作的攻击方法\">#</a> CSRF：跨站请求伪造    是一种挟持用户在已经登录的 web 应用程序上执行非本意操作的攻击方法</h2>\n<p>如何防御：</p>\n<ol>\n<li>get 请求不对数据进行修改</li>\n<li>不让第三方网站访问到用户的 Cookie                       对 cookie 设置 Samesite 属性，该属性设置 cookie 不随着跨域请求发送</li>\n<li>阻止第三方网站请求接口                                       验证 Referer 来判断请求是否由第三方网站发起的</li>\n<li>请求时附带验证信息，比如验证码或者 Cookie           服务器下发一个随机的 Token，每次用户发送请求的时候，必须携带这个 Token，然后服务器对其进行检验</li>\n</ol>\n<h2 id=\"密码安全\"><a class=\"markdownIt-Anchor\" href=\"#密码安全\">#</a> 密码安全</h2>\n<blockquote>\n<p>加盐：对于密码存储来说，必然是不能明文存储在数据库中，不然一旦数据库泄漏，会对用户造成巨大的损失。</p>\n<ul>\n<li>加盐就是给原密码添加字符串。加盐后的密码再进行一些列的加密算法处理。</li>\n<li>加盐并不能阻止别人盗取账号，只能确保即使数据库泄漏，也不会暴露用户的真实密码</li>\n<li>通常使用验证码增产时延或者限制尝试次数的方式，并且当输入错误时，不能提示密码输入错误，而是提示账号或者密码输入错误</li>\n</ul>\n</blockquote>\n<h2 id=\"三次握手\"><a class=\"markdownIt-Anchor\" href=\"#三次握手\">#</a> 三次握手</h2>\n<p>客户端：closed——》SYN  Send——》established</p>\n<p>服务端：closed——》Listened——》SYN Receive——》established</p>\n<blockquote>\n<p>为什么需要三次握手</p>\n</blockquote>\n<p>如果 A 向 B 发送了一个连接请求，由于网络延时原因，这个 A 发送的请求长时间没有被 B 接收，就会触发超时重传机制，重新发送的请求被 B 接收到后，两者顺利建立连接并开始传输信息或者数据，然后连接结束，两者处于 closed 状态。但此时，之前由于网络延时而未到达的请求到达了 B，B 以为 A 又要建立新的连接，便应答了请求，从而处于 established 状态，而此时 A 是 closed 状态，那么服务器就会一直等客户端传输数据，会造成资源浪费。</p>\n<h2 id=\"四次挥手\"><a class=\"markdownIt-Anchor\" href=\"#四次挥手\">#</a> 四次挥手</h2>\n<p><strong>断开连接时，两端都需要发送 FIN 和 ACK 信号</strong></p>\n<p>客户端：established——》FIN-WAIT-1——》FIN-WAIT-2——》TIME_WAIT——》closed</p>\n<p>服务端：established——》close-wait——》last-ack——》closed</p>\n<ul>\n<li>如果客户端 A 认为需要发送的数据已经发送完成，向给服务器 B 发送连接释放的请求</li>\n<li>B 收到释放请求后，会告诉应用层要释放 TCP 连接，然后发送 ACK 包，进入 close-wait 状态，表明 A 到 B 的连接已经释放，不再接收 A 发送的数据。但此时 B 仍然可以发送数据给 A</li>\n<li>B 如果此时还有没发送完的数据继续发送，数据发送完毕后，向 A 发送释放连接请求，然后 B 进入 last-ack 状态</li>\n<li>A 收到请求后，向 B 发送确认应答，此时 A 进入 Time-wait 状态。该状态会持续一个最大生命周期，如果该段时间内没有收到来自 B 的重发请求话，就进入 closed 状态，B 接收到 A 发送的确认信号后，进入 closed 状态。</li>\n</ul>\n<blockquote>\n<p>为什么 A 需要等待 2MSL 时间？</p>\n</blockquote>\n<p>为了确保 B 能够收到 A 发送的确认断开的信号，因为如果确认信息由于网络问题一直没有到达，就会导致 B 不能正常关闭。</p>\n<p><strong>拥塞处理</strong></p>\n<ul>\n<li>慢开始、拥塞避免</li>\n<li>快速重传、快速恢复</li>\n</ul>\n<h2 id=\"get请求和post请求\"><a class=\"markdownIt-Anchor\" href=\"#get请求和post请求\">#</a> get 请求和 post 请求</h2>\n<ul>\n<li>get 请求由于 url 长度的限制导致请求参数有长度限制，而 post 请求没有长度限制</li>\n<li>post 请求相对于 get 请求安全些，因为 get 请求参数都展示在 url 上</li>\n<li>post 可以通过 request body 传输更多的数据，而 get 没有这个技术</li>\n<li>post 支持更多的编码类型且不对数据类型限制</li>\n<li>在前端使用接口编写参数的时候，post 对于复杂的请求参数更容易编写</li>\n</ul>\n<h2 id=\"常见状态码\"><a class=\"markdownIt-Anchor\" href=\"#常见状态码\">#</a> 常见状态码</h2>\n<hr>\n<p><strong>2xx  成功</strong></p>\n<ul>\n<li><code>200 ok 表示客户端发送的请求被服务器正常处理</code></li>\n<li>204 no content  表示请求成功，但是响应报文不包含实体的主体部分</li>\n<li>205 reset content  与 204 一样，但是要求请求方重置内容</li>\n<li>206 partial Content   进行范围请求</li>\n</ul>\n<p><strong>3xx 重定向</strong></p>\n<ul>\n<li><code>301 moved  permanently    永久性重定向，表示资源已经被分配到新的url</code></li>\n<li><code>302 found   临时性重定向</code></li>\n<li>303   see other  表示资源存在着另一个 URL，应该使用 get 方法请求资源</li>\n</ul>\n<p><strong>4xx  客户端错误</strong></p>\n<ul>\n<li><code>400 bad request  请求报文存在语法错误</code></li>\n<li><code>401 unauthorized  表示发送的请求需要有HTTP认证的认证信息</code></li>\n<li><code>402  forbidden   请求资源被服务器拒绝</code></li>\n<li><code>404  not found   服务器没有找到请求的资源</code></li>\n</ul>\n<p><strong>5xx  服务器错误</strong></p>\n<ul>\n<li><code>500 internal server error  服务器在执行请求时发生了错误</code></li>\n<li>501 not implemented   服务器不支持当前请求的某个功能</li>\n<li><code>503  service unavailable   服务器此时处于超负载或者正在停机维护，无法处理请求</code></li>\n</ul>\n<h2 id=\"https\"><a class=\"markdownIt-Anchor\" href=\"#https\">#</a> HTTPS</h2>\n<p>HTTPS 还是通过 HTTP 进行信息的传输，但是信息通过 TLS 协议进行了加密。</p>\n<p>TLS 使用了两种加密技术：对称加密和非对称加密。</p>\n<ul>\n<li>\n<p>对称加密指两边具有相同的密钥，两边都知道将密文进行加密解密</p>\n</li>\n<li>\n<p>非对称加密，有公钥和私钥之分，公钥所有人都知道，可以将数据用公钥进行加密，但是数据只能用私钥进行解密，而私钥只有发放公钥的一方知道</p>\n</li>\n<li>\n<p>一般双方确认通信前使用非对称加密方式，一旦双方确认后，为了提高性能，两端使用对称加密的方式进行通信</p>\n</li>\n</ul>\n<blockquote>\n<p>TLS 握手过程</p>\n</blockquote>\n<ol>\n<li>客户端发送一个随机值，需要的协议以及加密方式</li>\n<li>服务端收到这个随机值，自己也产生一个随机值，根据客户端发来的协议和加密方式进行处理，发送自己的证书</li>\n<li>客户端收到这个证书并检验是否有效，通过后会再产生一个随机值，通过服务端证书的公钥加密这个随机值并发送给服务端（如果服务端需要客户端证书，需要携带）</li>\n<li>服务端收到这个加密的随机值使用私钥进行解密，这时候两端都有三个随机值，可以通过这三个随机值通过约定的加密方式生成密钥，后面的通信使用这个密钥进行加密解密</li>\n</ol>\n<blockquote>\n<p>HTTPS 2.0</p>\n</blockquote>\n<p>1.x 中，为了性能考虑，我们常常使用精灵图，将小图内联等方式，主要是因为浏览器限制了同一域名下的请求数量，当页面请求的资源过多时，会造成队头阻塞，一些资源需要等待其它资源请求完毕后才能发起请求。</p>\n<blockquote>\n<p>HTTPS 2.0 改进的地方</p>\n</blockquote>\n<ul>\n<li>二进制传输 ：  文本传输数据 ——》新的编码方式，数据被分割，采用二进制编码方式</li>\n<li>多路复用 ：     两个概念：帧 和 流   帧是最小的数据单位，多个帧组成数据流   多路复用就是在一个 TCP 连接中可以存在多条流，解决了队头阻塞的问题</li>\n<li>Header 压缩 ：  在之前的版本中，使用文本形式传输 headers  且携带 cookie 的情况下，每次都要重复传输大量字节   2.0 中使用了 HPACK 对传输的 header 进行压缩，并在两端维护了索引表，用于记录出现过的 headers，后面传输过程中，就只需要穿记录的 haders 的键名，服务端收到键名后可以找到对应的值</li>\n<li>服务端 PUSH  ：服务端在收到客户端的请求后，主动推送一些其它资源</li>\n</ul>\n<h2 id=\"dns\"><a class=\"markdownIt-Anchor\" href=\"#dns\">#</a> DNS</h2>\n<blockquote>\n<p><strong>将域名解析为 IP 的过程，查询过程主要有：迭代查询和递归查询（比较少用）两种</strong></p>\n</blockquote>\n<p><strong>迭代查询过程</strong>（本地域名服务器向根域名服务器的查询采用迭代查询）</p>\n<ol>\n<li>客户机向本地域名服务器发送 DNS 请求报文（递归查询）</li>\n<li>本地域名服务器收到请求后，查询本地缓存，如果没有记录，以 DNS 客户的身份向根域名服务器发送请求</li>\n<li>根域名服务器收到请求后，判断该域名为.com 域，并将顶级域名服务器 dns.com 的 ip 地址返回给本地域名服务器</li>\n<li>本地域名服务器向顶级域名服务器 dns.com 发送 DNS 请求（迭代查询）</li>\n<li>顶级域名服务器收到请求后，判断该域属于 abc.com 域，因此将对应的授权域名服务器 dns.abc.com 的 IP 地址返回给本地域名服务器</li>\n<li>本地域名服务器向授权域名服务器发送请求</li>\n<li>授权域名服务器收到请求后，将查询结果返回给本地域名服务器</li>\n<li>本地域名服务器将查询结果保存到本地缓存后，同时返回给客户机</li>\n</ol>\n<blockquote>\n<p>总结：客户机 ——》本地域名服务器 ——》根域名服务器 ——》本地域名服务器 ——》顶级域名服务器 ——》本地域名服务器 ——》授权域名服务器 ——》本地域名服务器 ——》主机</p>\n</blockquote>\n<blockquote>\n<p><strong>地址栏输入 URL 到页面加载完成的过程</strong></p>\n</blockquote>\n<ol>\n<li>DNS 查询，返回 IP 地址（DNS 查询 IP 的过程）</li>\n<li>TCP 握手（TCP 握手过程）</li>\n<li>TLS 握手，然后开始正式的数据传输（TLS 握手过程）</li>\n<li>数据进入服务端之前，可能会经过负责负载均衡的服务器（将请求合理的分发到多台服务器上），假设服务端响应一个 HTML 文件</li>\n<li>首先，浏览器会判断状态码，如果是 200 继续解析，如果是 400（客户端请求数据出现错误）或者 500（浏览器处理请求错误）会报错，如果是 300 的话，会进行重定向，这里会有个重定向计时器，避免多次重定向，超多一定的次数也会报错</li>\n<li>浏览器开始解析 HTML 文件，如果是 gzip 格式还需要先进行解压，通过文件的编码方式得知如何去解压这个文件</li>\n<li>文件解码成功后，开始正式的渲染流程。根据 HTML 构造 DOM 树，根据 CSS 构建 CSSOM 树。如果遇到 script 标签，会检查是否包含 <code>async</code>  和 <code>defer</code> ，前者会并行下载执行 JS，后者会先下载文件，然后等 HTML 解析完成后顺序执行，如果上述两种属性都没有，就会阻塞渲染流程，知道 JS 代码加载完毕，引入外部资源需要下载，如果资源比较多，长时间的下载，会阻塞页面的渲染流程，导致页面长时间没有响应。</li>\n<li>初始的 HTML 被完全加载和解析后会触发 DomContentLoaded 事件</li>\n<li>CSSOM 树和 DOM 树构建完成后开始生成 Render 树，同时计算元素的坐标，确定元素的布局</li>\n<li>在 Render 树的过程中，浏览器开始调用 GPU 绘制，将内容展示在屏幕上</li>\n</ol>\n",
            "tags": [
                "计算机网络"
            ]
        },
        {
            "id": "http://csstar.top/2020/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/",
            "url": "http://csstar.top/2020/10/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0/",
            "title": "计算机组成原理复习",
            "date_published": "2020-10-03T12:23:32.000Z",
            "content_html": "<h1 id=\"重点知识点\"><a class=\"markdownIt-Anchor\" href=\"#重点知识点\">#</a> 重点知识点</h1>\n<p>IEEE754 标准的 32/64 位浮点数的表示方法、补码的加减运算、双符号位运算判断是否溢出、指令格式的设计、存储器的扩展问题、静态存储图、SRAM 结构图、cache 的相关计算、寻址方式、CPU 模型、指令周期、双总线数据通路、指令周期流程图、ALU 运算器的结构图、微指令格式设计、微程序控制器、流水线时空图以及一些相关计算（吞吐率，加速比）、总线带宽、磁盘计算、刷新存储器、中断原理。</p>\n<h1 id=\"cache的相关计算\"><a class=\"markdownIt-Anchor\" href=\"#cache的相关计算\">#</a> cache 的相关计算</h1>\n<ol>\n<li>\n<p>命中率 H = 访问 cache 的次数 /（访问 cache 次数 + 访问主存的次数）</p>\n</li>\n<li>\n<p>平均访问时间 t=H✖访问 cache 的平均时间 +（1-H）✖访问主存的平均时间</p>\n</li>\n<li>\n<p>主存慢于 cache 的倍率 r = 访问主存平均的时间 / 访问 cache 的平均时间</p>\n</li>\n<li>\n<p>访问频率 e=t（c）/  t（a） =  1/ （r+（1-r）h）</p>\n</li>\n</ol>\n<h1 id=\"磁盘的相关计算\"><a class=\"markdownIt-Anchor\" href=\"#磁盘的相关计算\">#</a> 磁盘的相关计算</h1>\n<ol>\n<li>平均存储时间 = 找道时间 + 等待时间（1/2r） + 数据传输时间（b/rN）</li>\n<li>有效存储区域：外半径 - 内半径</li>\n<li>圆柱面 = 道密度✖有效存储区域</li>\n<li>每道信息量 N：有效道周长✖位密度 D</li>\n<li>每道信息量：每道信息量✖圆柱面</li>\n<li>总存储量：每道信息量✖有效面数</li>\n<li>数据传输率：D（r）=r（转速）✖N（每道信息量）    D（r）=D（位密度）✖ v（线速度）</li>\n</ol>\n<h1 id=\"ieee754标准\"><a class=\"markdownIt-Anchor\" href=\"#ieee754标准\">#</a> IEEE754 标准</h1>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>阶符</th>\n<th>阶码</th>\n<th>数值位</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>32 位浮点数</td>\n<td>1 位</td>\n<td>8 位</td>\n<td>23 位</td>\n</tr>\n<tr>\n<td>64 位浮点数</td>\n<td>1 位</td>\n<td>11 位</td>\n<td>52 位</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>注意：阶码用移码来表示，其中 32 位在指数的基础上加上 127，64 位在指数的基础上加上 1023</p>\n</blockquote>\n<h1 id=\"补码加减法\"><a class=\"markdownIt-Anchor\" href=\"#补码加减法\">#</a> 补码加减法</h1>\n<blockquote>\n<p>正数的补码是本身，负数的补码是符号位不变，数值为取反，末尾加一；</p>\n<p>符号的最高位进位应该丢弃；</p>\n<p>采用双符号位补码运算可确定是否溢出；</p>\n<p>y 的补码求 - y 补码的原则：包含符号位取反末尾加一；</p>\n</blockquote>\n<p>公式：</p>\n<p>x 的补码 + y 的补码 =  （x+y）的补码</p>\n<p>x 的补码 - y 的补码   = x 的补码 + （-y）的补码 = （x-y）的补码</p>\n<h1 id=\"机器的指令格式\"><a class=\"markdownIt-Anchor\" href=\"#机器的指令格式\">#</a> 机器的指令格式</h1>\n<table>\n<thead>\n<tr>\n<th>操作码</th>\n<th>寻址位</th>\n<th>数据域</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>与指令的数量有关</td>\n<td>与寻址方式的数量有关</td>\n<td>机器字长减去前面两个域的位数</td>\n</tr>\n</tbody>\n</table>\n<p>以上是单地址的表示方法，还有双地址，三地址的表示方法。</p>\n<h1 id=\"主存地址格式\"><a class=\"markdownIt-Anchor\" href=\"#主存地址格式\">#</a> 主存地址格式</h1>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>第一个域</th>\n<th>第二个域</th>\n<th>第三个域</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>直接映射方式</td>\n<td>标记（s-r）</td>\n<td>行号 r</td>\n<td>字地址 w</td>\n</tr>\n<tr>\n<td>组相联映射方式</td>\n<td>标记（s-d）</td>\n<td>组号 d</td>\n<td>字地址 w</td>\n</tr>\n<tr>\n<td>全相联映射方式</td>\n<td>标记 s</td>\n<td>字地址 w</td>\n<td>无，只有两个域</td>\n</tr>\n</tbody>\n</table>\n<p>解释：</p>\n<ol>\n<li>w 的计算：与块的大小有关</li>\n<li>d 的计算：组数    （cache 的行数 = 组数✖每组的行数）</li>\n<li>s 的计算：与主存的块数有关</li>\n<li>主存地址的长度：（s+w）</li>\n<li>主存寻址单元数 + 主存容量：2 的（s+w）次方</li>\n</ol>\n<blockquote>\n<p>单位的换算：1MB  = 2 的 20 次方 B     1KB = 2 的 10 次方 B</p>\n<p>同时注意 B 和 b 的区别，前者为字节，后者为比特，一个字节等于八个比特</p>\n</blockquote>\n<h1 id=\"存储器存储信息\"><a class=\"markdownIt-Anchor\" href=\"#存储器存储信息\">#</a> 存储器存储信息</h1>\n<p>存储位元总数：存储器容量（2 的地址位）✖存储器的字长</p>\n<p>如：16 位地址，32 位字长的 RAM 存储器</p>\n<p>存储容量为：2 的 16 次方✖2 的 5 次方 / 8  = 2 的 18 次方个字节</p>\n<h1 id=\"流水cpu\"><a class=\"markdownIt-Anchor\" href=\"#流水cpu\">#</a> 流水 CPU</h1>\n<p>同一个处理机同一时间只能处理一个程序。</p>\n<p>吞吐率（每秒钟执行完毕的指令条数） =  总指令条数 / 总时间</p>\n<p>加速比：非流水 CPU 所耗的时间 /  流水 CPU 耗时</p>\n<h1 id=\"微指令格式\"><a class=\"markdownIt-Anchor\" href=\"#微指令格式\">#</a> 微指令格式</h1>\n<table>\n<thead>\n<tr>\n<th>操作控制 OP</th>\n<th>测试字段 P</th>\n<th>地址字段 A</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>操作控制</td>\n<td>顺序控制</td>\n<td>顺序控制</td>\n</tr>\n</tbody>\n</table>\n<p>控存容量：1024✖64 位 —&gt; 地址字段有 10 位</p>\n<p>测试字段的位数：与控制转移条件的个数有关</p>\n<p>操作控制字段：微指令字长减去上面两个字段所占的位数</p>\n<blockquote>\n<p>控制存储器：只读存储器，存放全部指令系统的微程序；</p>\n<p>微指令寄存器：微命令寄存器，负责存放 P 字段和控制字段。微地址寄存器，存放下一条微指令的地址信息。</p>\n<p>地址转移逻辑：微程序出现分支时，根据测试标志的状态，去对微地址寄存器中的内容进行修改。</p>\n</blockquote>\n<h1 id=\"中断\"><a class=\"markdownIt-Anchor\" href=\"#中断\">#</a> 中断</h1>\n<p>定义：</p>\n<blockquote>\n<p>子程序的数据准备就绪时，向 CPU 发送请求中断的信号。（我理解的是请求暂时中断主程序，来服务子程序，子程序处理完后，返回主程序继续执行）</p>\n</blockquote>\n<p>注意：</p>\n<blockquote>\n<ul>\n<li>向 CPU 发送中断信号的同时，同时将 “中断屏蔽触发器” 置为 1，关闭中断请求，防止其它程序中断请求</li>\n<li>处理完子程序，“中断屏蔽触发器” 置为 0，开放，便于其它子程序发送中断请求信号</li>\n</ul>\n</blockquote>\n<p>其它概念:</p>\n<blockquote>\n<p>保护现场：将 PC 内容、CPU 状态等保存到堆栈中；</p>\n<p>四个标志触发器：RD（准备就绪）、EI（允许中断触发器）、IR（中断寄存器）、IM（中断屏蔽触发器）；</p>\n<p>单级中断 / 多级中断</p>\n</blockquote>\n<h1 id=\"寻址方式\"><a class=\"markdownIt-Anchor\" href=\"#寻址方式\">#</a> 寻址方式</h1>\n<h2 id=\"指令的寻址方式\"><a class=\"markdownIt-Anchor\" href=\"#指令的寻址方式\">#</a> 指令的寻址方式</h2>\n<blockquote>\n<p>总共有两种：顺序寻址方式和跳跃寻址方式</p>\n</blockquote>\n<h2 id=\"操作数的基本寻址方式\"><a class=\"markdownIt-Anchor\" href=\"#操作数的基本寻址方式\">#</a> 操作数的基本寻址方式</h2>\n<blockquote>\n<p>隐含寻址、立即寻址、直接寻址、间接寻址、寄存器寻址、寄存器间接寻址、偏移寻址、堆栈寻址。</p>\n</blockquote>\n",
            "tags": [
                "计算机组成原理"
            ]
        },
        {
            "id": "http://csstar.top/2020/09/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/",
            "url": "http://csstar.top/2020/09/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/",
            "title": "设计模式之单例模式",
            "date_published": "2020-09-21T11:07:10.000Z",
            "content_html": "<h1 id=\"概括\"><a class=\"markdownIt-Anchor\" href=\"#概括\">#</a> 概括</h1>\n<h2 id=\"定义\"><a class=\"markdownIt-Anchor\" href=\"#定义\">#</a> 定义</h2>\n<p>单例模式指在内存中只会创建一次且仅创建一次对象的模式。</p>\n<h2 id=\"原因\"><a class=\"markdownIt-Anchor\" href=\"#原因\">#</a> 原因</h2>\n<p>该模式是为了防止创建多个对象造成的资源浪费和管理困难的问题，仅在内存中创建一个对象，让有需要调用的地方都使用这一个单例对象。</p>\n<h2 id=\"两种模式\"><a class=\"markdownIt-Anchor\" href=\"#两种模式\">#</a> 两种模式</h2>\n<p>饿汉式：只有在需要调用对象的时候采取调用单例对象。</p>\n<p>懒汉式：类加载的时候就已经创建好了单例对象，随时等待调用。</p>\n<h1 id=\"使用方法\"><a class=\"markdownIt-Anchor\" href=\"#使用方法\">#</a> 使用方法</h1>\n<h2 id=\"懒汉式\"><a class=\"markdownIt-Anchor\" href=\"#懒汉式\">#</a> 懒汉式：</h2>\n<p>当程序需要使用对象的时候，先判断对象是否已经实例化，如果没有，则实例化对象，如果已经实例化，则直接返回对象。</p>\n<p><strong>示意图：</strong></p>\n<p><img src=\"http://qh82kvit3.hn-bkt.clouddn.com/clipboard-1601039788093.png\" alt></p>\n<p><strong>实例代码：</strong></p>\n<p><img src=\"http://qh82kvit3.hn-bkt.clouddn.com/clipboard-1601039836972.png\" alt=\"avatar\"></p>\n<h2 id=\"饿汉模式\"><a class=\"markdownIt-Anchor\" href=\"#饿汉模式\">#</a> 饿汉模式</h2>\n<p>类加载的时候直接创建单例对象，当需要调用时，直接使用这个已经创建好的单例对象就行</p>\n<p><strong>示意图：</strong></p>\n<p><img src=\"http://qh82kvit3.hn-bkt.clouddn.com/clipboard-1601039865541.png\" alt=\"avatar\"></p>\n<p><strong>示例代码：</strong></p>\n<p><img src=\"http://qh82kvit3.hn-bkt.clouddn.com/clipboard-1601039888935.png\" alt=\"avatar\"></p>\n<p><strong>注意：</strong></p>\n<p>类在加载的时候会在内存中实例化一个对象，当类被撤除时，这个对象也会随之消失。</p>\n<h1 id=\"改进和优化\"><a class=\"markdownIt-Anchor\" href=\"#改进和优化\">#</a> 改进和优化</h1>\n<h2 id=\"懒汉模式的优化\"><a class=\"markdownIt-Anchor\" href=\"#懒汉模式的优化\">#</a> 懒汉模式的优化</h2>\n<p>问题 1：如果两个线程同时判断不存在已经实例化的对象，那么这两个线程都会实例化对象，就产生了两个对象，不符合单例模式。这里涉及到线程并发的问题。</p>\n<p><strong>示意图：</strong></p>\n<p><img src=\"http://qh82kvit3.hn-bkt.clouddn.com/clipboard-1601039901878.png\" alt=\"avatar\"></p>\n<p><strong>解决方案 1：</strong></p>\n<p>在方法上或类对象上加锁</p>\n<p><strong>synchronized 的解释：</strong></p>\n<p>同步代码块中的锁，当有一个线程执行同步代码时，别的线程就不能执行此代码块。</p>\n<p><strong>示例代码：</strong></p>\n<p><img src=\"http://qh82kvit3.hn-bkt.clouddn.com/clipboard-1601039914173.png\" alt=\"avatar\"></p>\n<p>问题 2：以上很好地解决了多个线程可能同时创建多个对象的情况，但是，每次去获取对象的时候都要先获取锁，并发性能非常的差，可能情况下，会出现卡帧的情况。</p>\n<p><strong>解决方案 2：</strong></p>\n<p>性能优化。如果还没有实例化对象，就需要先获取锁，一旦对象已经实例化后，就可以省去获取锁的过程。所以不能直接在方法上加锁。</p>\n<p><strong>示例代码：</strong></p>\n<p><img src=\"http://qh82kvit3.hn-bkt.clouddn.com/clipboard-1601039929391.png\" alt=\"avatar\"></p>\n<p>因此，解决了线程并发和性能优化的问题。</p>\n<p><strong>解释：</strong></p>\n<p>【1】，第一个分支判断是否已经实例化对象，如果已经实例化，则直接返回对象，如果没有的话，就会进入下一个分支。</p>\n<p>【2】，多个线程获取争抢同一个锁，第一个获取锁的线程，就获取了判断的资格，会判断是否有其他线程已经实例化对象了，如果没有，就会实例化一个对象。也因此有了第一个且唯一的对象，当其他进程再次进行判断时，已经有了对象，就会直接返回实例化的对象，而不会再去创建对象。</p>\n<p>【3】懒汉模式可总结为：双重校验 + 锁。</p>\n<p><strong>完整代码：</strong></p>\n<p><img src=\"http://qh82kvit3.hn-bkt.clouddn.com/clipboard-1601039941802.png\" alt=\"avatar\"></p>\n<p><strong>volatile 防止指令重排：</strong></p>\n<p><strong>创建一个对象，在 JVM 中会经过三步：</strong></p>\n<p>（1）为 singleehan 分配内存空间</p>\n<p>（2）初始化 singleehan 对象</p>\n<p>（3）将 singleehan 指向分配好的内存空间</p>\n<p><strong>指令重排序：</strong></p>\n<p>JVM 在保证最终结果正确的情况下，可以不按照程序编码的顺序执行语句，仅可能提高程序的性能。</p>\n<p><img src=\"http://qh82kvit3.hn-bkt.clouddn.com/clipboard-1601039959416.png\" alt=\"avatar\"></p>\n<p><strong>volatile 的作用：</strong></p>\n<p>使用 volatile 关键字修饰的变量，可以保证其指令执行的顺序与程序指明的顺序一致，不会发生顺序变换，这样在多线程环境下就不会发生 NPE 异常了。volatile 还有第二个作用：使用 volatile 关键字修饰的变量，可以保证其内存可见性，即每一时刻线程读取到该变量的值都是内存中最新的那个值，线程每次操作该变量都需要先读取该变量。</p>\n<p>因此，会需要对上述代码进行如下改进：</p>\n<p><img src=\"http://qh82kvit3.hn-bkt.clouddn.com/clipboard.png\" alt=\"avatar\"></p>\n<p><strong>目的：为了防止指令重排导致的 NPE 异常。</strong></p>\n<h1 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h1>\n<p>1，单例模式有两种类型：懒汉式和饿汉式。</p>\n<p>2，懒汉式：只有需要调用的时候才回去创建对象，实现方法：双重校验 + 锁 + volatile 防止指令重排</p>\n<p>3，饿汉式：类加载的时候就会初始化实例对象，等待着被调用。不存在并发和性能的问题。</p>\n<p>4，如果对于内存要求不高，那么就是用饿汉式，好处是不容易出错；如果对于内存的要求很高，就是用懒汉式。</p>\n<p>5，为了防止多线程环境下，因为指令重排序导致变量报 NPE，需要在单例对象上添加 volatile 关键字防止指令重排序。</p>\n",
            "tags": [
                "设计模式"
            ]
        }
    ]
}