{
    "version": "https://jsonfeed.org/version/1",
    "title": "CsStar • All posts by \"dom\" tag",
    "description": "Work Hard To Be A Better Man",
    "home_page_url": "http://csstar.top",
    "items": [
        {
            "id": "http://csstar.top/2022/03/12/%E8%99%9A%E6%8B%9FDOM/",
            "url": "http://csstar.top/2022/03/12/%E8%99%9A%E6%8B%9FDOM/",
            "title": "虚拟DOM",
            "date_published": "2022-03-12T14:23:14.000Z",
            "content_html": "<h1 id=\"虚拟dom\"><a class=\"markdownIt-Anchor\" href=\"#虚拟dom\">#</a> 虚拟 DOM</h1>\n<h2 id=\"真实dom及其解析流程\"><a class=\"markdownIt-Anchor\" href=\"#真实dom及其解析流程\">#</a> 真实 DOM 及其解析流程</h2>\n<blockquote>\n<p>浏览器渲染引擎工作流程</p>\n</blockquote>\n<p>创建 DOM 树 ——》创建样式规则 ——》创建 Render 树 ——》布局 Layout——》绘制 painting</p>\n<ol>\n<li>HTML 分析器分析 HTML 元素，构建 DOM 树</li>\n<li>CSS 分析器分析 CSS 样式以及内联样式，生成页面的样式表</li>\n<li>将 DOM 树和样式表相关联，构建一颗 Render 树，这一过程称为 Attachment，每个 DOM 节点有 attach 方法，接收样式信息，返回 render 对象，这些 render 对象最终构建成一颗 render 树</li>\n<li>有了 Render 树，浏览器开始布局，为每个 render 对象在显示屏上确定精确坐标</li>\n<li>render 树和节点坐标都有了，然后调用每个节点的 paint 方法，进行页面绘制</li>\n</ol>\n<blockquote>\n<p>需要注意的几个问题</p>\n</blockquote>\n<ul>\n<li>DOM 树的构建是从文档加载完成开始的？</li>\n</ul>\n<p>构建 DOM 是一个渐进过程，为了提高用户体验度，需要尽快将渲染内容显示在页面上</p>\n<ul>\n<li>Render 树是 DOM 树和 CSS 样式表都构建完毕后才开始构建的吗？</li>\n</ul>\n<p>交叉进行的，一边加载、一边解析、一边渲染</p>\n<ul>\n<li>CSS 的解析是从右往左逆向解析的</li>\n</ul>\n<p>DOM 树从下往上解析比从上往下解析效率高，嵌套标签越多，解析越慢</p>\n<p><img src=\"/2022/03/12/%E8%99%9A%E6%8B%9FDOM/hexo.png\" alt></p>\n<h2 id=\"js操作真实dom\"><a class=\"markdownIt-Anchor\" href=\"#js操作真实dom\">#</a> JS 操作真实 DOM</h2>\n<p>原生 JS 或者 JQ 操作 DOM 时，浏览器会从构建 DOM 树开始从头到尾执行一遍流程。比如我们要更新多个 DOM 节点，浏览器会依次从头到尾进行执行，最终执行多次，其中包含了大量无用操作。频繁计算 DOM 节点坐标浪费了大量的性能，同时影响用户体验</p>\n<h2 id=\"虚拟dom-2\"><a class=\"markdownIt-Anchor\" href=\"#虚拟dom-2\">#</a> 虚拟 DOM</h2>\n<blockquote>\n<p>虚拟 DOM 就是为了解决浏览器性能问题而被设计出来的。</p>\n</blockquote>\n<p>对于多次更新 DOM 的操作，虚拟 DOM 不会立即执行 DOM，而是将这些 DOM 操作的更新经过 diff 算法后的内容保存到本地一个 JS 对象中，最终将这个 JS 对象一次性 attach 到 DOM 树上，再进行后续操作，避免了大量无用计算。</p>\n<p>页面的更新先反应到 JS 对象上，操作内存中的 JS 对象速度要快得多，更新完成后，再将最终的 JS 对象映射成真实的 DOM，交给浏览器去绘制。</p>\n<blockquote>\n<p>选择 diff 算法</p>\n</blockquote>\n<p>两棵树完全比较的时间复杂度是 O (n^3)，实际上 Reacte 的 diff 算法的时间复杂度为 O（n）。要实现这么低的时间复杂度，意味着只能比较平层的比较两棵树的节点，放弃了深度遍历。这样是一种以精确度换速度的做法，并且现实中前端页面通常也不会跨层移动 DOM 元素，使用这种算法是最优的。</p>\n<ul>\n<li>第一步，调用 patch 方法，传入新旧虚拟 DOM 进行同层对比</li>\n<li>第二步，调用 isSameNode 方法，对比新旧节点是否是同类型节点</li>\n<li>第三步， 如果不同，那么新节点将代替旧节点</li>\n<li>第四步，如果相同，调用 patchNode 进行节点对比\n<ol>\n<li>如果新旧节点都是文本节点，则新文本代替旧文本</li>\n<li>如果旧节点有子节点而新节点没有，则删除旧节点的子节点</li>\n<li>如果旧节点没有子节点，新节点有，则把子节点新增上去</li>\n<li>如果都有子节点，则调用 updateChildren 方法进行新旧子节点的对比</li>\n<li>子节点对比为首位对比法</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>附参考文档链接：<a class=\"link\" href=\"https://www.jianshu.com/p/af0b398602bc\">https://www.jianshu.com/p/af0b398602bc<i class=\"fas fa-external-link-alt\"></i></a></p>\n</blockquote>\n",
            "tags": [
                "DOM"
            ]
        }
    ]
}