<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://csstar.top</id>
    <title>CsStar • Posts by &#34;vue&#34; tag</title>
    <link href="http://csstar.top" />
    <updated>2022-03-12T14:23:14.000Z</updated>
    <category term="Docker" />
    <category term="ES7-11" />
    <category term="Pandas" />
    <category term="快捷操作" />
    <category term="前端学习网站" />
    <category term="前端知识" />
    <category term="机器学习" />
    <category term="小的知识点" />
    <category term="Vue" />
    <category term="计算机组成原理" />
    <category term="单例模式" />
    <category term="页面渲染模式" />
    <category term="ES6" />
    <entry>
        <id>http://csstar.top/2022/03/12/%E8%99%9A%E6%8B%9FDOM/</id>
        <title>虚拟DOM</title>
        <link rel="alternate" href="http://csstar.top/2022/03/12/%E8%99%9A%E6%8B%9FDOM/"/>
        <content type="html">&lt;h1 id=&#34;虚拟dom&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#虚拟dom&#34;&gt;#&lt;/a&gt; 虚拟 DOM&lt;/h1&gt;
&lt;h2 id=&#34;真实dom及其解析流程&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#真实dom及其解析流程&#34;&gt;#&lt;/a&gt; 真实 DOM 及其解析流程&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;浏览器渲染引擎工作流程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;创建 DOM 树 ——》创建样式规则 ——》创建 Render 树 ——》布局 Layout——》绘制 painting&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;HTML 分析器分析 HTML 元素，构建 DOM 树&lt;/li&gt;
&lt;li&gt;CSS 分析器分析 CSS 样式以及内联样式，生成页面的样式表&lt;/li&gt;
&lt;li&gt;将 DOM 树和样式表相关联，构建一颗 Render 树，这一过程称为 Attachment，每个 DOM 节点有 attach 方法，接收样式信息，返回 render 对象，这些 render 对象最终构建成一颗 render 树&lt;/li&gt;
&lt;li&gt;有了 Render 树，浏览器开始布局，为每个 render 对象在显示屏上确定精确坐标&lt;/li&gt;
&lt;li&gt;render 树和节点坐标都有了，然后调用每个节点的 paint 方法，进行页面绘制&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;需要注意的几个问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;DOM 树的构建是从文档加载完成开始的？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;构建 DOM 是一个渐进过程，为了提高用户体验度，需要尽快将渲染内容显示在页面上&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Render 树是 DOM 树和 CSS 样式表都构建完毕后才开始构建的吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;交叉进行的，一边加载、一边解析、一边渲染&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CSS 的解析是从右往左逆向解析的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DOM 树从下往上解析比从上往下解析效率高，嵌套标签越多，解析越慢&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;%E8%99%9A%E6%8B%9FDOM/hexo.png&#34; alt&gt;&lt;/p&gt;
&lt;h2 id=&#34;js操作真实dom&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#js操作真实dom&#34;&gt;#&lt;/a&gt; JS 操作真实 DOM&lt;/h2&gt;
&lt;p&gt;原生 JS 或者 JQ 操作 DOM 时，浏览器会从构建 DOM 树开始从头到尾执行一遍流程。比如我们要更新多个 DOM 节点，浏览器会依次从头到尾进行执行，最终执行多次，其中包含了大量无用操作。频繁计算 DOM 节点坐标浪费了大量的性能，同时影响用户体验&lt;/p&gt;
&lt;h2 id=&#34;虚拟dom-2&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#虚拟dom-2&#34;&gt;#&lt;/a&gt; 虚拟 DOM&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;虚拟 DOM 就是为了解决浏览器性能问题而被设计出来的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于多次更新 DOM 的操作，虚拟 DOM 不会立即执行 DOM，而是将这些 DOM 操作的更新经过 diff 算法后的内容保存到本地一个 JS 对象中，最终将这个 JS 对象一次性 attach 到 DOM 树上，再进行后续操作，避免了大量无用计算。&lt;/p&gt;
&lt;p&gt;页面的更新先反应到 JS 对象上，操作内存中的 JS 对象速度要快得多，更新完成后，再将最终的 JS 对象映射成真实的 DOM，交给浏览器去绘制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;选择 diff 算法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;两棵树完全比较的时间复杂度是 O (n^3)，实际上 Reacte 的 diff 算法的时间复杂度为 O（n）。要实现这么低的时间复杂度，意味着只能比较平层的比较两棵树的节点，放弃了深度遍历。这样是一种以精确度换速度的做法，并且现实中前端页面通常也不会跨层移动 DOM 元素，使用这种算法是最优的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一步，调用 patch 方法，传入新旧虚拟 DOM 进行同层对比&lt;/li&gt;
&lt;li&gt;第二步，调用 isSameNode 方法，对比新旧节点是否是同类型节点&lt;/li&gt;
&lt;li&gt;第三步， 如果不同，那么新节点将代替旧节点&lt;/li&gt;
&lt;li&gt;第四步，如果相同，调用 patchNode 进行节点对比
&lt;ol&gt;
&lt;li&gt;如果新旧节点都是文本节点，则新文本代替旧文本&lt;/li&gt;
&lt;li&gt;如果旧节点有子节点而新节点没有，则删除旧节点的子节点&lt;/li&gt;
&lt;li&gt;如果旧节点没有子节点，新节点有，则把子节点新增上去&lt;/li&gt;
&lt;li&gt;如果都有子节点，则调用 updateChildren 方法进行新旧子节点的对比&lt;/li&gt;
&lt;li&gt;子节点对比为首位对比法&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;附参考文档链接：&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9hZjBiMzk4NjAyYmM=&#34;&gt;https://www.jianshu.com/p/af0b398602bc&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</content>
        <category term="Vue" />
        <updated>2022-03-12T14:23:14.000Z</updated>
    </entry>
</feed>
