{
    "version": "https://jsonfeed.org/version/1",
    "title": "CsStar • All posts by \"单例模式\" tag",
    "description": "Work Hard To Be A Better Man",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2020/09/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/",
            "url": "http://example.com/2020/09/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/",
            "title": "设计模式之单例模式",
            "date_published": "2020-09-21T11:07:10.000Z",
            "content_html": "<h1 id=\"概括\"><a class=\"markdownIt-Anchor\" href=\"#概括\">#</a> 概括</h1>\n<h2 id=\"定义\"><a class=\"markdownIt-Anchor\" href=\"#定义\">#</a> 定义</h2>\n<p>单例模式指在内存中只会创建一次且仅创建一次对象的模式。</p>\n<h2 id=\"原因\"><a class=\"markdownIt-Anchor\" href=\"#原因\">#</a> 原因</h2>\n<p>该模式是为了防止创建多个对象造成的资源浪费和管理困难的问题，仅在内存中创建一个对象，让有需要调用的地方都使用这一个单例对象。</p>\n<h2 id=\"两种模式\"><a class=\"markdownIt-Anchor\" href=\"#两种模式\">#</a> 两种模式</h2>\n<p>饿汉式：只有在需要调用对象的时候采取调用单例对象。</p>\n<p>懒汉式：类加载的时候就已经创建好了单例对象，随时等待调用。</p>\n<h1 id=\"使用方法\"><a class=\"markdownIt-Anchor\" href=\"#使用方法\">#</a> 使用方法</h1>\n<h2 id=\"懒汉式\"><a class=\"markdownIt-Anchor\" href=\"#懒汉式\">#</a> 懒汉式：</h2>\n<p><strong>当程序需要使用对象的时候，先判断对象是否已经实例化，如果没有，则实例化对象，如果已经实例化，则直接返回对象。</strong></p>\n<p><strong>示意图：</strong></p>\n<p><img data-src=\"%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.assets/clipboard.png\" alt=\"img\"></p>\n<p><strong>实例代码：</strong></p>\n<p><img data-src=\"%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.assets/clipboard.png\" alt=\"img\"></p>\n<h2 id=\"饿汉模式\"><a class=\"markdownIt-Anchor\" href=\"#饿汉模式\">#</a> 饿汉模式</h2>\n<p><strong>类加载的时候直接创建单例对象，当需要调用时，直接使用这个已经创建好的单例对象就行</strong></p>\n<p><strong>示意图：</strong></p>\n<p><img data-src=\"%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.assets/clipboard.png\" alt=\"img\"></p>\n<p><strong>示例代码：</strong></p>\n<p><img data-src=\"%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.assets/clipboard.png\" alt=\"img\"></p>\n<p><strong>注意：</strong></p>\n<p><strong>类在加载的时候会在内存中实例化一个对象，当类被撤除时，这个对象也会随之消失。</strong></p>\n<h1 id=\"改进和优化\"><a class=\"markdownIt-Anchor\" href=\"#改进和优化\">#</a> 改进和优化</h1>\n<h2 id=\"懒汉模式的优化\"><a class=\"markdownIt-Anchor\" href=\"#懒汉模式的优化\">#</a> 懒汉模式的优化</h2>\n<p><strong>问题 1：如果两个线程同时判断不存在已经实例化的对象，那么这两个线程都会实例化对象，就产生了两个对象，不符合单例模式。这里涉及到线程并发的问题。</strong></p>\n<p><strong>示意图：</strong></p>\n<p><img data-src=\"%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.assets/clipboard.png\" alt=\"img\"></p>\n<p><strong>解决方案 1：</strong></p>\n<p><strong>在方法上或类对象上加锁</strong></p>\n<p><strong>synchronized 的解释：</strong></p>\n<p><strong>同步代码块中的锁，当有一个线程执行同步代码时，别的线程就不能执行此代码块。</strong></p>\n<p><strong>示例代码：</strong></p>\n<p><img data-src=\"%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.assets/clipboard.png\" alt=\"img\"></p>\n<p><strong>问题 2：以上很好地解决了多个线程可能同时创建多个对象的情况，但是，每次去获取对象的时候都要先获取锁，并发性能非常的差，可能情况下，会出现卡帧的情况。</strong></p>\n<p><strong>解决方案 2：</strong></p>\n<p><strong>性能优化。如果还没有实例化对象，就需要先获取锁，一旦对象已经实例化后，就可以省去获取锁的过程。所以不能直接在方法上加锁。</strong></p>\n<p><strong>示例代码：</strong></p>\n<p><img data-src=\"%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.assets/clipboard.png\" alt=\"img\"></p>\n<p><strong>因此，解决了线程并发和性能优化的问题。</strong></p>\n<p><strong>解释：</strong></p>\n<p><strong>【1】，第一个分支判断是否已经实例化对象，如果已经实例化，则直接返回对象，如果没有的话，就会进入下一个分支。</strong></p>\n<p><strong>【2】，多个线程获取争抢同一个锁，第一个获取锁的线程，就获取了判断的资格，会判断是否有其他线程已经实例化对象了，如果没有，就会实例化一个对象。也因此有了第一个且唯一的对象，当其他进程再次进行判断时，已经有了对象，就会直接返回实例化的对象，而不会再去创建对象。</strong></p>\n<p><strong>【3】懒汉模式可总结为：双重校验 + 锁。</strong></p>\n<p><strong>完整代码：</strong></p>\n<p><img data-src=\"%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.assets/clipboard.png\" alt=\"img\"></p>\n<p><strong>volatile 防止指令重排：</strong></p>\n<p><strong>创建一个对象，在 JVM 中会经过三步：</strong></p>\n<p>（1）为 singleehan 分配内存空间</p>\n<p>（2）初始化 singleehan 对象</p>\n<p>（3）将 singleehan 指向分配好的内存空间</p>\n<p><strong>指令重排序：</strong></p>\n<p><strong>JVM 在保证最终结果正确的情况下，可以不按照程序编码的顺序执行语句，仅可能提高程序的性能。</strong></p>\n<p><img data-src=\"%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.assets/clipboard.png\" alt=\"img\"></p>\n<p><strong>volatile 的作用：</strong></p>\n<p><strong>使用 volatile 关键字修饰的变量，可以保证其指令执行的顺序与程序指明的顺序一致，不会发生顺序变换，这样在多线程环境下就不会发生 NPE 异常了。</strong></p>\n<p><strong>volatile 还有第二个作用：使用 volatile 关键字修饰的变量，可以保证其内存可见性，即每一时刻线程读取到该变量的值都是内存中最新的那个值，线程每次操作该变量都需要先读取该变量。</strong></p>\n<p><strong>因此，会需要对上述代码进行如下改进：</strong></p>\n<p><img data-src=\"%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.assets/clipboard.png\" alt=\"img\"></p>\n<p><strong>目的：为了防止指令重排导致的 NPE 异常。</strong></p>\n<h1 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h1>\n<p><strong>1，单例模式有两种类型：懒汉式和饿汉式。</strong></p>\n<p><strong>2，懒汉式：只有需要调用的时候才回去创建对象，实现方法：双重校验 + 锁 + volatile 防止指令重排</strong></p>\n<p><strong>3，饿汉式：类加载的时候就会初始化实例对象，等待着被调用。不存在并发和性能的问题。</strong></p>\n<p><strong>4，如果对于内存要求不高，那么就是用饿汉式，好处是不容易出错；如果对于内存的要求很高，就是用懒汉式。</strong></p>\n<p><strong>5，为了防止多线程环境下，因为指令重排序导致变量报 NPE，需要在单例对象上添加 volatile 关键字防止指令重排序。</strong></p>\n",
            "tags": [
                "单例模式"
            ]
        }
    ]
}